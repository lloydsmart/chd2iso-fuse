name: Security checks (cargo-deny & cargo-audit)

on:
  push:
    branches: [ develop, main ]
  pull_request:
    branches: [ develop, main ]
  schedule:
    - cron: "30 3 * * 1"
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: sec-checks-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # GATE: PRs only; push/schedule/manual always run
  gate:
    name: Decide if checks are needed (PRs)
    runs-on: ubuntu-latest
    outputs:
      needs_ci: ${{ steps.export.outputs.needs_ci }}
    steps:
      - name: Mode
        id: mode
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "is_pr=true" >>"$GITHUB_OUTPUT"
          else
            echo "is_pr=false" >>"$GITHUB_OUTPUT"
          fi

      - name: Export for non-PR
        if: steps.mode.outputs.is_pr == 'false'
        id: export_nonpr
        run: echo "needs_ci=true" >>"$GITHUB_OUTPUT"

      - name: Identify back-merge PR (main → develop)
        if: steps.mode.outputs.is_pr == 'true'
        id: bm
        run: |
          if [[ "${{ github.event.pull_request.base.ref }}" == "develop" && \
                "${{ github.event.pull_request.head.ref }}" == "main" ]]; then
            echo "is_backmerge=true" >>"$GITHUB_OUTPUT"
          else
            echo "is_backmerge=false" >>"$GITHUB_OUTPUT"
          fi

      - name: Checkout (full, only for back-merge eval)
        if: steps.mode.outputs.is_pr == 'true' && steps.bm.outputs.is_backmerge == 'true'
        uses: actions/checkout@v5
        with: { fetch-depth: 0 }

      - name: Compare & conflict probe (only for back-merge PRs)
        if: steps.mode.outputs.is_pr == 'true' && steps.bm.outputs.is_backmerge == 'true'
        id: diff
        run: |
          set -euo pipefail
          git remote set-url origin "${{ github.server_url }}/${{ github.repository }}"
          git fetch --no-tags --prune origin \
            +refs/heads/develop:refs/remotes/origin/develop \
            +refs/heads/main:refs/remotes/origin/main
          read A B < <(git rev-list --left-right --count origin/develop...origin/main)
          echo "ahead_on_develop=${A}" >>"$GITHUB_OUTPUT"
          git checkout -q -B tmp origin/develop
          if git merge --no-commit --no-ff origin/main >/dev/null 2>&1; then
            echo "conflicts=false" >>"$GITHUB_OUTPUT"
            git merge --abort || true
          else
            echo "conflicts=true" >>"$GITHUB_OUTPUT"
            git merge --abort || true
          fi

      - name: Decide (PR)
        if: steps.mode.outputs.is_pr == 'true'
        id: export_pr
        run: |
          if [[ "${{ steps.bm.outputs.is_backmerge }}" != "true" ]]; then
            echo "needs_ci=true" >>"$GITHUB_OUTPUT"
            exit 0
          fi
          A="${{ steps.diff.outputs.ahead_on_develop || '0' }}"
          C="${{ steps.diff.outputs.conflicts || 'false' }}"
          if [[ "$C" == "true" || "$A" -gt 0 ]]; then
            echo "needs_ci=true" >>"$GITHUB_OUTPUT"
          else
            echo "needs_ci=false" >>"$GITHUB_OUTPUT"
          fi

      - name: Export final
        id: export
        run: |
          if [[ "${{ steps.mode.outputs.is_pr }}" == "true" ]]; then
            echo "needs_ci=${{ steps.export_pr.outputs.needs_ci }}" >>"$GITHUB_OUTPUT"
          else
            echo "needs_ci=${{ steps.export_nonpr.outputs.needs_ci }}" >>"$GITHUB_OUTPUT"
          fi

  security:
    name: cargo-deny • cargo-audit
    needs: gate
    if: |
      !(
        github.event_name == 'pull_request' &&
        (
          (github.base_ref == 'develop' && github.head_ref == 'main') ||
          contains(github.event.pull_request.title, 'Back-merge') ||
          contains(github.event.pull_request.title, 'back-merge') ||
          contains(toJson(github.event.pull_request.labels), 'back-merge')
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 20

    env:
      ACCEPTED: ${{ vars.RUSTSEC_ACCEPTED_ADVISORIES || secrets.RUSTSEC_ACCEPTED_ADVISORIES || '' }}
      CARGO_TERM_COLOR: always

    steps:
      - name: Checkout (shallow)
        uses: actions/checkout@v5
        with: { fetch-depth: 1 }

      - name: Determine if Rust/package files changed (for cargo-audit skip)
        id: paths
        uses: dorny/paths-filter@v3
        with:
          filters: |
            rust:
              - 'src/**'
              - '**/*.rs'
              - 'Cargo.toml'
              - 'Cargo.lock'
              - 'build.rs'
              - 'debian/**'

      # Prebuilt binaries — no Rust toolchain needed
      - name: Install cargo-deny (prebuilt)
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-deny@latest
      - run: cargo-deny --version

      - name: Install cargo-audit (prebuilt)
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-audit@latest
      - run: cargo audit --version

      # One shared DAILY cache for RustSec advisory DB
      - name: Day key
        id: day
        run: echo "day=$(date +%Y-%j)" >> "$GITHUB_OUTPUT"

      - name: Cache RustSec advisory DB
        uses: actions/cache@v4
        with:
          path: ~/.cargo/advisory-db
          key: rustsec-db-${{ runner.os }}-${{ steps.day.outputs.day }}
          restore-keys: |
            rustsec-db-${{ runner.os }}-

      # ---- cargo-deny ----
      - name: Fetch advisory DB (warm-up)
        run: cargo-deny fetch

      - name: Check advisories (locked; enforces per-waiver expiry)
        run: cargo-deny --locked check advisories

      - name: Check bans & licenses (policy hygiene; locked)
        run: cargo-deny --locked check bans licenses

      - name: Export cargo-deny reports
        run: |
          mkdir -p reports
          cargo-deny --locked check advisories --format json > reports/cargo-deny-advisories.json
          cargo-deny --locked check bans       --format json > reports/cargo-deny-bans.json
          cargo-deny --locked check licenses   --format json > reports/cargo-deny-licenses.json

      # ---- cargo-audit ----
      - name: No-op (non-code PR; skip cargo-audit)
        if: ${{ steps.paths.outputs.rust != 'true' && github.event_name == 'pull_request' }}
        run: echo "No Rust/package changes in this PR; skipping cargo-audit."

      - name: Ensure Cargo.lock exists
        if: ${{ steps.paths.outputs.rust == 'true' || github.event_name != 'pull_request' }}
        run: |
          set -euo pipefail
          [ -f Cargo.lock ] || cargo generate-lockfile

      - name: Run cargo-audit (JSON)
        if: ${{ steps.paths.outputs.rust == 'true' || github.event_name != 'pull_request' }}
        run: |
          mkdir -p reports
          cargo audit -D warnings --json > reports/cargo-audit.json

      # ---- PR comment summary (only on PRs) ----
      - name: Summarize & comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            function readJsonSafe(path) {
              try {
                if (!fs.existsSync(path)) return null;
                const raw = fs.readFileSync(path, 'utf8').trim();
                if (!raw) return null;
                return JSON.parse(raw);
              } catch (e) {
                return null;
              }
            }

            function countDeny(file) {
              const data = readJsonSafe(file);
              if (!data || !Array.isArray(data)) return {errors: 0, warnings: 0, notes: 0};
              let errors = 0, warnings = 0, notes = 0;
              for (const item of data) {
                const lvl = (item.level || '').toLowerCase();
                if (lvl === 'error') errors++;
                else if (lvl === 'warning') warnings++;
                else if (lvl === 'note') notes++;
              }
              return {errors, warnings, notes};
            }

            function summarizeAudit(file) {
              const data = readJsonSafe(file);
              if (!data || !data.vulnerabilities) return {vulns: 0, warnings: 0};
              const vulns = data.vulnerabilities.count || 0;
              const warnings = Array.isArray(data.warnings) ? data.warnings.length : 0;
              return {vulns, warnings};
            }

            const denyAdv = countDeny('reports/cargo-deny-advisories.json');
            const denyBans = countDeny('reports/cargo-deny-bans.json');
            const denyLic  = countDeny('reports/cargo-deny-licenses.json');
            const auditSum = summarizeAudit('reports/cargo-audit.json');

            const totalDenyErrors   = denyAdv.errors + denyBans.errors + denyLic.errors;
            const totalDenyWarnings = denyAdv.warnings + denyBans.warnings + denyLic.warnings;

            const okBadge = (ok) => ok ? '✅' : '❌';

            const summary = `
<!-- security-checks-summary -->
### Security checks summary

**cargo-deny**
| Check       | Errors | Warnings | Notes |
|-------------|:------:|:--------:|:-----:|
| advisories  | ${denyAdv.errors} | ${denyAdv.warnings} | ${denyAdv.notes} |
| bans        | ${denyBans.errors} | ${denyBans.warnings} | ${denyBans.notes} |
| licenses    | ${denyLic.errors} | ${denyLic.warnings} | ${denyLic.notes} |
| **total**   | **${totalDenyErrors}** | **${totalDenyWarnings}** | **${denyAdv.notes + denyBans.notes + denyLic.notes}** |

**cargo-audit**
- vulnerabilities: **${auditSum.vulns}**
- warnings: **${auditSum.warnings}**

**Status**: ${okBadge(totalDenyErrors === 0 && auditSum.vulns === 0)} (errors: ${totalDenyErrors}, vulns: ${auditSum.vulns})
`;

            core.summary.addRaw(summary).write();

            const {owner, repo} = context.repo;
            const issue_number = context.issue.number;

            const { data: comments } = await github.rest.issues.listComments({
              owner, repo, issue_number, per_page: 100
            });

            const existing = comments.find(c =>
              c.user?.type === 'Bot' &&
              typeof c.body === 'string' &&
              c.body.includes('<!-- security-checks-summary -->')
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner, repo,
                comment_id: existing.id,
                body: summary
              });
            } else {
              await github.rest.issues.createComment({
                owner, repo, issue_number,
                body: summary
              });
            }

      # Upload all JSON reports
      - name: Upload security reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: reports/*.json
