name: üöÄ Release (on tag)

on:
  push:
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      tag:
        description: 'üè∑Ô∏è Tag to build (e.g. v0.2.11). Leave empty to use event tag.'
        required: false

permissions:
  contents: write
  security-events: read

concurrency:
  group: release-${{ github.event_name == 'workflow_dispatch' && inputs.tag || github.ref }}
  cancel-in-progress: false

defaults:
  run:
    shell: bash

jobs:
  resolve_tag:
    name: üè∑Ô∏è Resolve tag for this run
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.out.outputs.tag }}
    steps:
      - id: out
        run: |
          set -euo pipefail
          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ] && [ -n "${{ inputs.tag }}" ]; then
            tag="${{ inputs.tag }}"
          else
            tag="${GITHUB_REF_NAME}"
          fi
          if [ -z "$tag" ]; then
            echo "::error::Unable to resolve tag."
            exit 1
          fi
          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "Resolved TAG=$tag"

  guard_tag_on_main:
    name: üõ°Ô∏è Guard ‚Äî tag must be on main
    needs: [resolve_tag]
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout full history + tags
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: üêõ Debug refs
        run: |
          set -euo pipefail
          echo "event_name=${GITHUB_EVENT_NAME}"
          echo "resolved_tag=${{ needs.resolve_tag.outputs.tag }}"
          git fetch --no-tags origin +refs/heads/main:refs/remotes/origin/main
          echo "origin/main -> $(git rev-parse refs/remotes/origin/main)"

      - name: üîç Verify tag commit is reachable from origin main
        run: |
          set -euo pipefail
          TAG="${{ needs.resolve_tag.outputs.tag }}"
          git fetch --no-tags origin +refs/heads/main:refs/remotes/origin/main
          TAG_SHA="$(git rev-parse "${TAG}^{commit}")"
          echo "Tag ${TAG} -> ${TAG_SHA}"
          if git merge-base --is-ancestor "${TAG_SHA}" origin/main; then
            echo "‚úÖ ${TAG} is contained in origin/main"
          else
            echo "::error::${TAG} (${TAG_SHA}) is NOT on main."
            exit 1
          fi

  build:
    name: üõ†Ô∏è Build for tag
    needs: [guard_tag_on_main]
    uses: ./.github/workflows/_build.yml
    with:
      lane: main
      nightly: false
      release_mode: true
    secrets: inherit

  verify_versions:
    name: üîé Verify versions
    needs: [build]
    uses: ./.github/workflows/_verify-release.yml
    secrets: inherit

  publish_release:
    name: üì¶ Publish GitHub Release
    needs: [build, verify_versions, resolve_tag]
    runs-on: ubuntu-latest
    steps:
      - name: üõ´ Preflight check (identity variables present)
        env:
          HAS_AUTHOR_NAME: ${{ vars.GIT_AUTHOR_NAME != '' }}
          HAS_AUTHOR_EMAIL: ${{ vars.GIT_AUTHOR_EMAIL != '' }}
        run: |
          set -euo pipefail
          if [ "${HAS_AUTHOR_NAME}" != "true" ]; then echo "::warning::Variable GIT_AUTHOR_NAME is not set (will use default)."; fi
          if [ "${HAS_AUTHOR_EMAIL}" != "true" ]; then echo "::warning::Variable GIT_AUTHOR_EMAIL is not set (will use default)."; fi

      - name: üì• Checkout full history + tags (for changelog generation)
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          fetch-tags: true
          clean: false

      - name: üë§ Configure git identity (from Actions Variables)
        run: |
          set -euo pipefail
          NAME="${{ vars.GIT_AUTHOR_NAME }}"
          EMAIL="${{ vars.GIT_AUTHOR_EMAIL }}"
          : "${NAME:=Release Bot}"
          : "${EMAIL:=release-bot@users.noreply.github.com}"
          git config --global user.name  "${NAME}"
          git config --global user.email "${EMAIL}"
          echo "Using git identity: ${NAME} <${EMAIL}>"

      - name: üêõ Debug tag
        run: echo "tag=${{ needs.resolve_tag.outputs.tag }}"

      - name: üì• Download build artifacts (release-artifacts)
        uses: actions/download-artifact@v4
        with:
          name: release-artifacts
          path: artifacts

      - name: üêõ Debug list downloaded artifact contents
        if: always()
        run: |
          set -euo pipefail
          echo "Downloaded files:"
          find artifacts -maxdepth 1 -type f -printf '%P\n' | sort || true

      - name: üõ°Ô∏è Guard expected release payload present (.deb)
        run: |
          set -euo pipefail
          shopt -s nullglob
          debs=(artifacts/*.deb)
          if [ ${#debs[@]} -eq 0 ]; then
            echo "::error::No .deb files found in artifacts/."
            find artifacts -maxdepth 2 -type f -printf '%P\n' | sort || true
            exit 1
          fi

      - name: üìù Ensure RELEASE_NOTES.md (prefer provided; otherwise generate via git-cliff with explicit from/to)
        id: notes
        run: |
          set -euo pipefail
          TAG="${{ needs.resolve_tag.outputs.tag }}"

          if [ -f artifacts/RELEASE_NOTES.md ]; then
            cp artifacts/RELEASE_NOTES.md RELEASE_NOTES.md
            echo "source=artifact" >> "$GITHUB_OUTPUT"
          else
            echo "No notes artifact found; generating with git-cliff‚Ä¶"
            echo "source=cliff" >> "$GITHUB_OUTPUT"

            PREV="$(git describe --tags --abbrev=0 "${TAG}^" 2>/dev/null || true)"
            echo "Resolved TAG=$TAG"
            echo "Previous tag=${PREV:-<none>}"

            # Debug: show candidate commits
            if [[ -n "${PREV}" ]]; then
              echo "== Commits in ${PREV}..${TAG} =="
              git log --oneline --no-decorate "${PREV}..${TAG}" || true
            else
              echo "== Recent commits up to ${TAG} (no previous tag found) =="
              git log --oneline --no-decorate -20 "${TAG}" || true
            fi

            # Ensure git-cliff is available
            if ! command -v git-cliff >/dev/null 2>&1; then
              echo "Installing git-cliff‚Ä¶"
              curl -sSfL https://raw.githubusercontent.com/taiki-e/install-action/main/install.sh | bash -s -- -b /usr/local/bin git-cliff
            fi

            printf "# Changelog\n\n" > CHANGELOG.md
            if [[ -n "${PREV}" ]]; then
              echo "Using explicit bounds: --from ${PREV} --to ${TAG}"
              git-cliff --from "${PREV}" --to "${TAG}" --prepend CHANGELOG.md
              git-cliff --from "${PREV}" --to "${TAG}" --output RELEASE_NOTES.md
            else
              # First release or no prior tag found; fall back to --tag
              git-cliff --tag "${TAG}" --prepend CHANGELOG.md
              git-cliff --tag "${TAG}" --output RELEASE_NOTES.md
            fi
          fi

      - name: üõ°Ô∏è Guard: release notes must be non-empty
        run: |
          set -euo pipefail
          if [[ ! -s RELEASE_NOTES.md ]] || grep -qx '(no notes)' RELEASE_NOTES.md; then
            echo "::error title=Empty release notes::RELEASE_NOTES.md is empty or '(no notes)'."
            PREV="$(git describe --tags --abbrev=0 "${{ needs.resolve_tag.outputs.tag }}^" 2>/dev/null || true)"
            if [[ -n "${PREV}" ]]; then
              echo "== Commits in ${PREV}..${{ needs.resolve_tag.outputs.tag }} =="; git log --oneline --no-decorate "${PREV}..${{ needs.resolve_tag.outputs.tag }}" || true
            fi
            exit 1
          fi

      - name: üîê Import GPG (for checksums signing)
        if: ${{ hashFiles('artifacts/SHA256SUMS') != '' }}
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}

      - name: ‚úçÔ∏è Sign SHA256SUMS (detached, into artifacts/)
        if: ${{ hashFiles('artifacts/SHA256SUMS') != '' }}
        run: |
          set -euo pipefail
          gpg --batch --yes --detach-sign --armor \
              -o artifacts/SHA256SUMS.asc artifacts/SHA256SUMS
          gpg --verify artifacts/SHA256SUMS.asc artifacts/SHA256SUMS

      - name: üì¶ Assemble release asset list (explicit)
        id: assets
        run: |
          set -euo pipefail
          shopt -s nullglob
          wanted=( artifacts/*.deb artifacts/SHA256SUMS artifacts/SHA256SUMS.asc artifacts/CHANGELOG.md artifacts/RELEASE_NOTES.md )
          files=()
          for f in "${wanted[@]}"; do
            for x in $f; do
              [ -f "$x" ] || continue
              cp -v "$x" .
              files+=("$(basename "$x")")
            done
          done
          if [ ${#files[@]} -eq 0 ]; then
            echo "::error::No files selected for upload"; exit 1
          fi
          {
            echo "files<<EOF"
            printf '%s\n' "${files[@]}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: üêõ Echo files to upload (debug)
        run: |
          echo "Files:"
          echo "${{ steps.assets.outputs.files }}" | sed 's/^/  - /'

      - name: üìÑ Create/ensure draft release (no assets yet)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.resolve_tag.outputs.tag }}
        run: |
          set -euo pipefail
          if ! gh release view "${TAG}" >/dev/null 2>&1; then
            gh release create "${TAG}" -t "chd2iso-fuse ${TAG}" -F RELEASE_NOTES.md --draft
          else
            gh release edit "${TAG}" --notes-file RELEASE_NOTES.md
          fi

      - name: ‚¨ÜÔ∏è Upload assets via gh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.resolve_tag.outputs.tag }}
        run: |
          set -euo pipefail
          mapfile -t files < <(printf '%s\n' "${{ steps.assets.outputs.files }}")
          if [ "${#files[@]}" -eq 0 ]; then
            echo "::error::No files to upload"; exit 1
          fi
          gh release upload "${TAG}" "${files[@]}" --clobber

      - name: üöÄ Publish the release (gh)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.resolve_tag.outputs.tag }}
        run: |
          set -euo pipefail
          gh release edit "${TAG}" --draft=false

      - name: üêõ Verify release assets (debug)
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const tag = `${{ needs.resolve_tag.outputs.tag }}`;
            const rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
            const names = rel.data.assets.map(a => a.name);
            core.info('Release assets: ' + JSON.stringify(names));

      - name: üìù Reconcile release title with tag (safety net)
        uses: actions/github-script@v7
        with:
          script: |
            const tag = `${{ needs.resolve_tag.outputs.tag }}`;
            const { owner, repo } = context.repo;
            const res = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
            const desired = `chd2iso-fuse ${tag}`;
            if (res.data.name !== desired) {
              await github.rest.repos.updateRelease({ owner, repo, release_id: res.data.id, name: desired });
              core.info(`Updated release title to '${desired}'`);
            } else {
              core.info('Release title already correct.');

  release_lane:
    name: üõ£Ô∏è Release lane and optional APT
    needs: [build, verify_versions, publish_release]
    uses: ./.github/workflows/_release.yml
    with:
      lane: main
      nightly: false
      apt_enabled: false
    secrets: inherit
