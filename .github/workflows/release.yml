name: Release (on tag)

on:
  push:
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to build (e.g. v0.2.11). Leave empty to use event tag.'
        required: false

permissions:
  contents: write
  security-events: read

concurrency:
  # Avoid collisions: for workflow_dispatch use the provided tag; for push use github.ref
  group: release-${{ github.event_name == 'workflow_dispatch' && inputs.tag || github.ref }}
  cancel-in-progress: false

defaults:
  run:
    shell: bash

jobs:
  resolve_tag:
    name: Resolve tag for this run
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.out.outputs.tag }}
    steps:
      - id: out
        run: |
          set -euo pipefail
          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ] && [ -n "${{ inputs.tag }}" ]; then
            tag="${{ inputs.tag }}"
          else
            # event is push on a tag
            tag="${GITHUB_REF_NAME}"
          fi
          if [ -z "$tag" ]; then
            echo "::error::Unable to resolve tag."
            exit 1
          fi
          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "Resolved TAG=$tag"

  guard_tag_on_main:
    name: Guard - tag must be on main
    needs: [resolve_tag]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Debug refs
        run: |
          set -euo pipefail
          echo "event_name=${GITHUB_EVENT_NAME}"
          echo "resolved_tag=${{ needs.resolve_tag.outputs.tag }}"
          git fetch --no-tags origin +refs/heads/main:refs/remotes/origin/main
          echo "origin/main -> $(git rev-parse refs/remotes/origin/main)"

      - name: Verify tag commit is reachable from origin main
        run: |
          set -euo pipefail
          TAG="${{ needs.resolve_tag.outputs.tag }}"
          git fetch --no-tags origin +refs/heads/main:refs/remotes/origin/main
          TAG_SHA="$(git rev-parse "${TAG}^{commit}")"
          echo "Tag ${TAG} -> ${TAG_SHA}"
          if git merge-base --is-ancestor "${TAG_SHA}" origin/main; then
            echo "OK: ${TAG} is contained in origin/main"
          else
            echo "::error::${TAG} (${TAG_SHA}) is NOT on main."
            exit 1
          fi

  build:
    name: Build for tag
    needs: [guard_tag_on_main]
    uses: ./.github/workflows/_build.yml
    with:
      lane: main
      nightly: false
    secrets: inherit

  verify_versions:
    name: Verify versions
    needs: [build]
    uses: ./.github/workflows/_verify-release.yml
    secrets: inherit

  publish_release:
    name: Publish GitHub Release
    needs: [build, verify_versions, resolve_tag]
    runs-on: ubuntu-latest
    steps:
      - name: Preflight check (identity variables present)
        env:
          HAS_AUTHOR_NAME: ${{ vars.GIT_AUTHOR_NAME != '' }}
          HAS_AUTHOR_EMAIL: ${{ vars.GIT_AUTHOR_EMAIL != '' }}
        run: |
          set -euo pipefail
          if [ "${HAS_AUTHOR_NAME}" != "true" ]; then echo "::warning::Variable GIT_AUTHOR_NAME is not set (will use default)."; fi
          if [ "${HAS_AUTHOR_EMAIL}" != "true" ]; then echo "::warning::Variable GIT_AUTHOR_EMAIL is not set (will use default)."; fi

      - name: Debug tag
        run: echo "tag=${{ needs.resolve_tag.outputs.tag }}"

      - name: Configure git identity (from Actions Variables)
        run: |
          set -euo pipefail
          NAME="${{ vars.GIT_AUTHOR_NAME }}"
          EMAIL="${{ vars.GIT_AUTHOR_EMAIL }}"
          : "${NAME:=Release Bot}"
          : "${EMAIL:=release-bot@users.noreply.github.com}"
          git config --global user.name  "${NAME}"
          git config --global user.email "${EMAIL}"
          echo "Using git identity: ${NAME} <${EMAIL}>"

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: "artifacts"
          merge-multiple: true

      - name: Guard artifacts exist
        run: |
          set -euo pipefail
          shopt -s nullglob
          deb=(artifacts/*.deb)
          bi=(artifacts/*.buildinfo)
          ch=(artifacts/*.changes)
          if [ ${#deb[@]} -eq 0 ] && [ ${#bi[@]} -eq 0 ] && [ ${#ch[@]} -eq 0 ]; then
            echo "No artifacts found in ./artifacts"
            exit 1
          fi
          find "artifacts" -maxdepth 2 -type f -printf '%P\n' | sort || true

      - name: Ensure RELEASE_NOTES.md
        run: |
          set -euo pipefail
          if [ -f artifacts/RELEASE_NOTES.md ]; then
            cp artifacts/RELEASE_NOTES.md RELEASE_NOTES.md
          elif [ -f artifacts/CHANGELOG.md ]; then
            cp artifacts/CHANGELOG.md RELEASE_NOTES.md
          else
            echo "(no release notes provided)" > RELEASE_NOTES.md
          fi
          sed -n '1,120p' RELEASE_NOTES.md || true

      # üîê SIGN BEFORE ASSEMBLING THE UPLOAD LIST
      - name: Import GPG (for checksums signing)
        if: ${{ hashFiles('artifacts/SHA256SUMS') != '' }}
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}

      - name: Sign SHA256SUMS (detached, into artifacts/)
        if: ${{ hashFiles('artifacts/SHA256SUMS') != '' }}
        run: |
          set -euo pipefail
          gpg --batch --yes --detach-sign --armor \
              -o artifacts/SHA256SUMS.asc artifacts/SHA256SUMS
          gpg --verify artifacts/SHA256SUMS.asc artifacts/SHA256SUMS

      - name: Assemble asset list
        id: assets
        run: |
          set -euo pipefail
          shopt -s nullglob
          files=()
          for f in artifacts/*.deb artifacts/*.buildinfo artifacts/*.changes artifacts/SHA256SUMS artifacts/SHA256SUMS.asc; do
            [ -e "$f" ] || continue
            cp -v "$f" .
            files+=("$(basename "$f")")
          done
          {
            echo 'ASSET_FILES<<EOF'
            printf '%s\n' "${files[@]}"
            echo 'EOF'
          } >> "$GITHUB_ENV"

      - name: Create draft release and upload
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.resolve_tag.outputs.tag }}
          name: "chd2iso-fuse ${{ needs.resolve_tag.outputs.tag }}"
          body_path: "RELEASE_NOTES.md"
          generate_release_notes: false
          draft: true
          fail_on_unmatched_files: false
          files: ${{ env.ASSET_FILES }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish draft
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.resolve_tag.outputs.tag }}
          draft: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Reconcile release title with tag (safety net)
        uses: actions/github-script@v7
        with:
          script: |
            const tag = `${{ needs.resolve_tag.outputs.tag }}`;
            try {
              const res = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner, repo: context.repo.repo, tag
              });
              const desired = `chd2iso-fuse ${tag}`;
              if (res.data.name !== desired) {
                await github.rest.repos.updateRelease({
                  owner: context.repo.owner, repo: context.repo.repo,
                  release_id: res.data.id, name: desired
                });
                core.info(`Updated release title to '${desired}'`);
              } else {
                core.info('Release title already correct.');
              }
            } catch (e) {
              core.setFailed(`Failed to reconcile title: ${e.message}`);
            }

  release_lane:
    name: Release lane and optional APT
    needs: [build, verify_versions, publish_release]
    uses: ./.github/workflows/_release.yml
    with:
      lane: main
      nightly: false
      apt_enabled: false
    secrets: inherit
