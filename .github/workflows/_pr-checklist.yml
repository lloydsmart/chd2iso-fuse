name: Reusable — Update PR checklist ☑️

on:
  workflow_call:
    inputs:
      items:
        description: "Literal checklist items to tick (one per line, must appear in PR body)"
        type: string
        default: ""
      regex_items:
        description: "Regex patterns (one per line, case-insensitive) to match checklist items"
        type: string
        default: ""
      comment:
        description: "Optional comment to post after updating checklist"
        type: string
        default: ""
      remove_label:
        description: "Optional label to remove after updating checklist"
        type: string
        default: ""
      ready:
        description: "If true, attempt to mark PR Ready for review after ticking"
        type: boolean
        default: false
      require_all:
        description: "If true, only flip Ready when ALL requested items are checked"
        type: boolean
        default: false

permissions:
  contents: read
  pull-requests: write

jobs:
  update:
    name: Tick checklist & update PR
    runs-on: ubuntu-latest
    steps:
      - name: ☑️ Update PR checklist
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;

            // --- helpers ---
            const norm = (s) =>
              (s || "")
                .replace(/\r/g, "")
                .replace(/^\s*[-*]\s*\[[ xX]\]\s*/m, "") // strip leading "- [ ]" or "* [ ]"
                .replace(/[`*_~]/g, "")                  // strip lightweight md
                .trim();

            const parseMultiline = (s) =>
              (s || "")
                .split(/\r?\n/)
                .map((v) => v.trim())
                .filter(Boolean);

            const literalNeedles = parseMultiline(`{{ inputs.items }}`).map((t) => t.toLowerCase());
            const regexNeedles = parseMultiline(`{{ inputs.regex_items }}`).map((p) => new RegExp(p, "i"));

            // --- find PR: prefer payload PR#; else by head ref; else scan open PRs ---
            let prNumber = undefined;
            if (context.payload.pull_request && context.payload.pull_request.number) {
              prNumber = context.payload.pull_request.number;
            }

            const headRef = (context.ref || "").replace(/^refs\/heads\//, "");
            if (!prNumber && headRef) {
              const prsByHead = await github.paginate(
                github.rest.pulls.list,
                { owner, repo, state: "open", head: `${owner}:${headRef}` }
              );
              if (prsByHead.length) prNumber = prsByHead[0].number;
            }

            if (!prNumber && headRef) {
              const openPRs = await github.paginate(github.rest.pulls.list, { owner, repo, state: "open" });
              const match = openPRs.find((p) => (p.head && p.head.ref) === headRef);
              if (match) prNumber = match.number;
            }

            if (!prNumber) {
              core.info(`No open PR found for head='${headRef}'. Nothing to do.`);
              return;
            }

            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            let body = pr.body || "";

            // Scan body, tick matching lines
            const lines = body.split(/\n/);
            let changed = false;

            // Track which requested items are now checked (for require_all)
            const requestedChecks = [];

            // Build a predicate that says if a task text matches any literal or regex
            const matchesRequested = (taskText) => {
              const textNorm = taskText.toLowerCase();
              if (literalNeedles.some((needle) => textNorm.includes(needle))) return true;
              if (regexNeedles.some((re) => re.test(taskText))) return true;
              return false;
            };

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];

              // Only consider markdown task list lines
              const m = line.match(/^(\s*[-*]\s*)\[( |x|X)\](\s*)(.*)$/);
              if (!m) continue;

              const [, bullet, box, spaceAfter, textRaw] = m;
              const text = norm(line); // normalized task text (no checkbox prefix etc.)

              const isMatch = matchesRequested(text);
              const isChecked = box.toLowerCase() === "x";

              // Record status for require_all (only for lines that match one of the requested items)
              if (isMatch) {
                requestedChecks.push(isChecked);
              }

              // If line matches a requested item and is unchecked -> tick it
              if (isMatch && !isChecked) {
                lines[i] = `${bullet}[x]${spaceAfter}${textRaw}`;
                changed = true;
              }
            }

            if (changed) {
              body = lines.join("\n");
              await github.rest.pulls.update({ owner, repo, pull_number: prNumber, body });
              core.info(`Updated checklist on PR #${prNumber}.`);
            } else {
              core.info(`Checklist already up-to-date or requested items not found on PR #${prNumber}.`);
            }

            // Optional: comment (only if provided and non-empty)
            const comment = `{{ inputs.comment }}`.trim();
            if (comment) {
              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: comment }).catch(() => {});
            }

            // Optional: remove a label
            const removeLabel = `{{ inputs.remove_label }}`.trim();
            if (removeLabel) {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: removeLabel }).catch(() => {});
            }

            // Optional: flip draft -> ready
            const wantReady = {{ inputs.ready }};
            const requireAll = {{ inputs.require_all }};
            if (wantReady) {
              // If require_all, ensure every requested item that exists in the body is now checked.
              let okToReady = true;
              if (requireAll) {
                // If none of the requested items were found at all, do NOT flip.
                if (requestedChecks.length === 0) {
                  okToReady = false;
                } else {
                  okToReady = requestedChecks.every(Boolean);
                }
              }

              if (okToReady) {
                // Re-fetch draft status in case it changed
                const { data: pr2 } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                if (pr2.draft) {
                  await github.rest.pulls.update({ owner, repo, pull_number: prNumber, draft: false });
                  core.info(`PR #${prNumber} marked Ready for review.`);
                } else {
                  core.info(`PR #${prNumber} already Ready for review.`);
                }
              } else {
                core.info("Not marking Ready for review: required items not all checked.");
              }
            }
