name: Reusable — Update PR checklist ☑️

on:
  workflow_call:
    inputs:
      items:
        description: "Literal checklist items to tick (one per line, must appear in PR body)"
        type: string
        default: ""
      regex_items:
        description: "Regex patterns (one per line, case-insensitive) to match checklist items"
        type: string
        default: ""
      comment:
        description: "Optional comment to post after updating checklist"
        type: string
        default: ""
      remove_label:
        description: "Optional label to remove after updating checklist"
        type: string
        default: ""
      ready:
        description: "If true, attempt to mark PR Ready for review after ticking"
        type: boolean
        default: false
      require_all:
        description: "If true, only flip Ready when ALL requested items are checked"
        type: boolean
        default: false

permissions:
  contents: read
  pull-requests: write

jobs:
  update:
    name: Tick checklist & update PR
    runs-on: ubuntu-latest
    steps:
      - name: ☑️ Update PR checklist
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;

            // -------- helpers --------
            const parseLines = (s) =>
              (s || "").split(/\r?\n/).map((v) => v.trimEnd()); // keep leading spaces for bullets

            const parseMultiline = (s) =>
              (s || "")
                .split(/\r?\n/)
                .map((v) => v.trim())
                .filter(Boolean);

            // Normalize the task "text" (without the "- [ ]" prefix), for matching
            const normTask = (s) =>
              (s || "")
                .replace(/\r/g, "")
                .replace(/^\s*[-*]\s*\[[ xX]\]\s*/,'') // strip checkbox prefix
                .replace(/[`\*_~]/g,'')                 // strip lightweight md
                .trim();

            // Build tolerant word-based fallback matcher: "version.*bump" -> ["version","bump"]
            const wordsFromPattern = (p) =>
              (p || "")
                .toLowerCase()
                .replace(/[^a-z0-9\s]/gi, " ")
                .split(/\s+/)
                .filter(Boolean);

            const literalNeedles = parseMultiline(`{{ inputs.items }}`).map((t) => t.toLowerCase());
            const regexNeedles = parseMultiline(`{{ inputs.regex_items }}`).map((p) => new RegExp(p, "i"));
            const wordNeedles  = parseMultiline(`{{ inputs.regex_items }}`).map(wordsFromPattern);

            // -------- find PR --------
            let prNumber;
            if (context.payload.pull_request?.number) {
              prNumber = context.payload.pull_request.number;
            }
            const headRef = (context.ref || "").replace(/^refs\/heads\//, "");
            if (!prNumber && headRef) {
              const prsByHead = await github.paginate(
                github.rest.pulls.list,
                { owner, repo, state: "open", head: `${owner}:${headRef}` }
              );
              if (prsByHead.length) prNumber = prsByHead[0].number;
            }
            if (!prNumber) {
              const openPRs = await github.paginate(github.rest.pulls.list, { owner, repo, state: "open" });
              const match = openPRs.find((p) => (p.head && p.head.ref) === headRef);
              if (match) prNumber = match.number;
            }
            if (!prNumber) {
              core.info(`No open PR found for head='${headRef}'. Nothing to do.`);
              return;
            }

            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            let body = pr.body || "";
            const lines = parseLines(body);

            core.info(`PR #${prNumber} found. Head: ${pr.head?.ref} | Draft: ${pr.draft ? "yes" : "no"}`);
            core.info(`Requested (literals): ${JSON.stringify(literalNeedles) || "<none>"}`);
            core.info(`Requested (regex):    ${parseMultiline(`{{ inputs.regex_items }}`).join(" | ") || "<none>"}`);

            // -------- tick tasks --------
            let changed = false;
            const requestedChecks = []; // for require_all gate

            // Helper: does a given task text match any requested literal/regex/words
            const matchesRequested = (taskText) => {
              const textLower = taskText.toLowerCase();

              // 1) literal "includes"
              if (literalNeedles.some((needle) => needle && textLower.includes(needle))) {
                return { matched: true, via: "literal" };
              }

              // 2) regex
              if (regexNeedles.some((re) => re.test(taskText))) {
                return { matched: true, via: "regex" };
              }

              // 3) word fallback (all words must appear)
              for (const words of wordNeedles) {
                if (!words.length) continue;
                const all = words.every((w) => textLower.includes(w));
                if (all) return { matched: true, via: "words" };
              }

              return { matched: false };
            };

            for (let i = 0; i < lines.length; i++) {
              const raw = lines[i];

              // Only process markdown task list lines
              const m = raw.match(/^(\s*[-*]\s*)\[( |x|X)\](\s*)(.*)$/);
              if (!m) continue;

              const [, bullet, box, spaceAfter, rest] = m;
              const isChecked = box.toLowerCase() === "x";
              const taskText = normTask(raw);

              const { matched, via } = matchesRequested(taskText);

              // For logs
              core.info(`task: "${taskText}" | checked=${isChecked} | match=${matched ? via : "no"}`);

              if (matched) {
                requestedChecks.push(isChecked);
                if (!isChecked) {
                  lines[i] = `${bullet}[x]${spaceAfter}${rest}`;
                  changed = true;
                  core.info(` -> ticked`);
                }
              }
            }

            if (changed) {
              body = lines.join("\n");
              await github.rest.pulls.update({ owner, repo, pull_number: prNumber, body });
              core.info(`Updated PR body (ticked ${requestedChecks.filter(Boolean).length}/${requestedChecks.length} requested items).`);
            } else {
              core.info(`No body changes needed. (${requestedChecks.filter(Boolean).length}/${requestedChecks.length} requested items already checked or not found)`);
            }

            // Optional: single, explicit comment
            const comment = `{{ inputs.comment }}`.trim();
            if (comment) {
              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: comment }).catch(() => {});
            }

            // Optional: remove a label
            const removeLabel = `{{ inputs.remove_label }}`.trim();
            if (removeLabel) {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: removeLabel }).catch(() => {});
            }

            // Optional: flip draft -> ready (with gating)
            const wantReady   = {{ inputs.ready }};
            const requireAll  = {{ inputs.require_all }};
            if (wantReady) {
              let okToReady = true;
              if (requireAll) {
                if (requestedChecks.length === 0) {
                  core.info("Ready gate: none of the requested items were found; not flipping.");
                  okToReady = false;
                } else if (!requestedChecks.every(Boolean)) {
                  core.info("Ready gate: not all requested items are checked; not flipping.");
                  okToReady = false;
                }
              }

              if (okToReady) {
                const { data: pr2 } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                if (pr2.draft) {
                  await github.rest.pulls.update({ owner, repo, pull_number: prNumber, draft: false });
                  core.info(`PR #${prNumber} marked Ready for review.`);
                } else {
                  core.info(`PR #${prNumber} already Ready for review.`);
                }
              }
            }
