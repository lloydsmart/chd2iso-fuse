name: Reusable — Update PR checklist ☑️

on:
  workflow_call:
    inputs:
      items:
        description: "Checklist items to tick (one per line; matches are fuzzy)"
        type: string
        required: true
      regex_items:
        description: "Optional regex matchers (one per line) to tick matching task lines"
        type: string
        default: ""
      comment:
        description: "Optional comment to post after updating checklist (rarely needed)"
        type: string
        default: ""
      remove_label:
        description: "Optional label to remove after updating checklist"
        type: string
        default: ""
      ready:
        description: "Attempt to set PR draft=false (Ready for review) after update"
        type: boolean
        default: false
      require_all:
        description: "Only flip to Ready if *all* required items are checked"
        type: boolean
        default: false
      required_items:
        description: "Required checklist items (one per line) that must be [x] to allow Ready flip"
        type: string
        default: ""
      required_regex_items:
        description: "Optional required regex matchers (one per line) that must match a checked task to allow Ready flip"
        type: string
        default: ""

permissions:
  contents: read
  pull-requests: write

jobs:
  update:
    name: Tick checklist & update PR
    runs-on: ubuntu-latest
    steps:
      - name: ☑️ Update PR checklist
        uses: actions/github-script@v8
        with:
          script: |
            // --- helpers -----------------------------------------------------
            function escapeRegex(s){return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')}
            function stripMd(s){
              return String(s)
                .replace(/`([^`]*)`/g, '$1')      // inline code
                .replace(/\*\*([^*]+)\*\*/g, '$1')// bold
                .replace(/\*([^*]+)\*/g, '$1')    // italic
                .replace(/__([^_]+)__/g, '$1')    // bold alt
                .replace(/_([^_]+)_/g, '$1')      // italic alt
                .replace(/~~([^~]+)~~/g, '$1')    // strikethrough
                .replace(/:\w+:/g, '')            // :emoji:
                .replace(/[，、。！!?:;,.]+$/g, '')// trailing punct
                .replace(/\s+/g, ' ')
                .trim()
                .toLowerCase();
            }

            const { owner, repo } = context.repo;

            // Derive head branch across PR/push/workflow_call
            const headRef =
              context.payload.pull_request?.head?.ref ||
              process.env.GITHUB_HEAD_REF ||
              (context.ref || '').replace('refs/heads/', '');

            if (!headRef) { core.info('No head branch could be determined; skipping.'); return; }

            // Guard (operate only on release/* or hotfix/*)
            if (!/^release\//.test(headRef) && !/^hotfix\//.test(headRef)) {
              core.info(`Branch '${headRef}' is not release/* or hotfix/*; skipping.`);
              return;
            }

            // Find open PR for this branch
            const prs = await github.paginate(
              github.rest.pulls.list,
              { owner, repo, state: 'open', head: `${owner}:${headRef}` }
            );
            if (!prs.length) { core.info(`No open PR for ${owner}:${headRef}; nothing to do.`); return; }
            const pr = prs[0];

            // Inputs (toJson to preserve newlines/quotes)
            const rawItems      = ${{ toJson(inputs.items) }};
            const rawRegexItems = ${{ toJson(inputs.regex_items) }};
            const commentIn     = ${{ toJson(inputs.comment) }};
            const removeLabel   = ${{ toJson(inputs.remove_label) }};
            const markReady     = ${{ inputs.ready }};       // boolean
            const requireAll    = ${{ inputs.require_all }}; // boolean
            const rawReqItems   = ${{ toJson(inputs.required_items) }};
            const rawReqRegex   = ${{ toJson(inputs.required_regex_items) }};

            const wanted = String(rawItems).split(/\r?\n/).map(s => stripMd(s)).filter(Boolean);
            const regexes = String(rawRegexItems).split(/\r?\n/).map(s => s.trim()).filter(Boolean).map(p => {
              try { return new RegExp(p, 'i'); } catch { core.warning(`Bad regex skipped: ${p}`); return null; }
            }).filter(Boolean);

            const required = String(rawReqItems).split(/\r?\n/).map(s => stripMd(s)).filter(Boolean);
            const requiredRegexes = String(rawReqRegex).split(/\r?\n/).map(s => s.trim()).filter(Boolean).map(p => {
              try { return new RegExp(p, 'i'); } catch { core.warning(`Bad required regex skipped: ${p}`); return null; }
            }).filter(Boolean);

            let body = pr.body || '';
            if (!body) { core.info('PR has empty body; nothing to tick.'); }

            // Tick any task list line whose normalized text matches wanted OR regexes
            const lines = body.split(/\r?\n/);
            let changed = false;

            const taskRe = /^([*\-]\s*\[\s*)([ xX])(\s*\]\s*)(.*)$/; // prefix, mark, suffix, text

            for (let i = 0; i < lines.length; i++) {
              const m = lines[i].match(taskRe);
              if (!m) continue;
              const [ , prefix, mark, suffix, text ] = m;

              if (/[xX]/.test(mark)) continue; // already checked

              const norm = stripMd(text);
              const hitWanted = wanted.some(w => norm === w || norm.includes(w));
              const hitRegex  = regexes.some(r => r.test(text) || r.test(norm));

              if (hitWanted || hitRegex) {
                lines[i] = `${prefix}x${suffix}${text}`;
                changed = true;
              }
            }

            if (changed) {
              body = lines.join('\n');
              await github.rest.pulls.update({ owner, repo, pull_number: pr.number, body });
              core.info(`Updated checklist on PR #${pr.number}.`);
            } else {
              core.info('No matching checklist items found to tick (format/labels may differ).');
            }

            // Optional comment — only post if provided AND not already present verbatim
            const comment = String(commentIn).trim();
            if (comment) {
              const existing = await github.paginate(github.rest.issues.listComments, {
                owner, repo, issue_number: pr.number, per_page: 100
              });
              if (!existing.some(c => (c.body || '').trim() === comment)) {
                await github.rest.issues.createComment({ owner, repo, issue_number: pr.number, body: comment }).catch(() => {});
              } else {
                core.info('Identical comment already exists; skipping duplicate.');
              }
            }

            // Optional label removal
            const labelToRemove = String(removeLabel).trim();
            if (labelToRemove) {
              await github.rest.issues.removeLabel({
                owner, repo, issue_number: pr.number, name: labelToRemove
              }).catch(() => {});
            }

            // Determine if all required items are currently checked in the (possibly updated) body
            const bodyLines = body.split(/\r?\n/);
            const checkedTaskRe = /^[*\-]\s*\[\s*[xX]\s*\]\s*(.*)$/;

            const checkedTexts = bodyLines
              .map(l => {
                const m = l.match(checkedTaskRe);
                return m ? m[1] : null;
              })
              .filter(Boolean);

            const checkedNorm = checkedTexts.map(stripMd);

            const requiredTextOk = required.every(req =>
              checkedNorm.some(ct => ct === req || ct.includes(req))
            );

            const requiredRegexOk = requiredRegexes.every(r =>
              checkedTexts.some(t => r.test(t)) || checkedNorm.some(n => r.test(n))
            );

            const allRequirementsMet = (!requireAll)
              ? true
              : (required.length === 0 && requiredRegexes.length === 0
                  ? false // if requireAll is true but nothing specified, never flip
                  : (requiredTextOk && requiredRegexOk));

            // Flip draft → ready only if requested AND (requirements met or not required)
            if (markReady === true && allRequirementsMet) {
              if (pr.draft) {
                await github.rest.pulls.update({ owner, repo, pull_number: pr.number, draft: false });
                core.info(`PR #${pr.number} marked Ready for review.`);
              } else {
                core.info('PR already Ready for review.');
              }
            } else if (markReady === true && !allRequirementsMet) {
              core.info('Ready flip requested but not all required items are checked; leaving as draft.');
            }
