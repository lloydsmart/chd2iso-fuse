name: Reusable — Update PR checklist ☑️

on:
  workflow_call:
    inputs:
      items:
        description: "Checklist items to tick (one per line; matches are fuzzy)"
        type: string
        required: true
      regex_items:
        description: "Optional regex matchers (one per line) to tick matching task lines"
        type: string
        default: ""
      comment:
        description: "Optional comment to post after updating checklist (rarely needed)"
        type: string
        default: ""
      remove_label:
        description: "Optional label to remove after updating checklist"
        type: string
        default: ""
      ready:
        description: "Attempt to set PR draft=false (Ready for review) after update"
        type: boolean
        default: false
      require_all:
        description: "Only flip to Ready if *all* required items are checked"
        type: boolean
        default: false
      required_items:
        description: "Required checklist items (one per line) that must be [x] to allow Ready flip"
        type: string
        default: ""

permissions:
  contents: read
  pull-requests: write

jobs:
  update:
    name: Tick checklist & update PR
    runs-on: ubuntu-latest
    steps:
      - name: ☑️ Update PR checklist
        uses: actions/github-script@v8
        with:
          script: |
            // ---------- helpers ----------
            function stripMd(s){
              return String(s)
                .replace(/`([^`]*)`/g, '$1')      // inline code
                .replace(/\*\*([^*]+)\*\*/g, '$1')// bold
                .replace(/\*([^*]+)\*/g, '$1')    // italic
                .replace(/__([^_]+)__/g, '$1')    // bold alt
                .replace(/_([^_]+)_/g, '$1')      // italic alt
                .replace(/~~([^~]+)~~/g, '$1')    // strikethrough
                .replace(/:\w+:/g, '')            // :emoji:
                .replace(/[，、。！!?:;,.]+$/g, '')// trailing punct
                .replace(/\s+/g, ' ')
                .trim()
                .toLowerCase();
            }

            const { owner, repo } = context.repo;

            // Derive head ref for PR lookup in push/PR/workflow_call
            const headRef =
              context.payload.pull_request?.head?.ref ||
              process.env.GITHUB_HEAD_REF ||
              (context.ref || '').replace('refs/heads/', '');

            if (!headRef) { core.info('No head branch; skipping.'); return; }

            // Only operate on release/* or hotfix/*
            if (!/^release\//.test(headRef) && !/^hotfix\//.test(headRef)) {
              core.info(`Branch '${headRef}' is not release/* or hotfix/*; skipping.`);
              return;
            }

            // Find open PR for this branch
            const prs = await github.paginate(
              github.rest.pulls.list,
              { owner, repo, state: 'open', head: `${owner}:${headRef}` }
            );
            if (!prs.length) { core.info(`No open PR for ${owner}:${headRef}.`); return; }
            const pr = prs[0];

            // Inputs (use toJson on caller side; here GH passes parsed values)
            const itemsStr       = ${{ toJson(inputs.items) }};
            const regexItemsStr  = ${{ toJson(inputs.regex_items) }};
            const commentStr     = ${{ toJson(inputs.comment) }};
            const removeLabelStr = ${{ toJson(inputs.remove_label) }};
            const ready          = ${{ inputs.ready }};
            const requireAll     = ${{ inputs.require_all }};
            const requiredStr    = ${{ toJson(inputs.required_items) }};

            const wanted = String(itemsStr).split(/\r?\n/).map(s => stripMd(s)).filter(Boolean);
            const regexes = String(regexItemsStr).split(/\r?\n/).map(s => s.trim()).filter(Boolean).map(p => {
              try { return new RegExp(p, 'i'); } catch { core.warning(`Bad regex skipped: ${p}`); return null; }
            }).filter(Boolean);
            const required = String(requiredStr).split(/\r?\n/).map(s => stripMd(s)).filter(Boolean);

            let body = pr.body || '';
            if (!body) core.info('PR has empty body; nothing to tick.');

            // Tick items by fuzzy or regex match
            const lines = (body || '').split(/\r?\n/);
            const taskRe = /^([*\-]\s*\[\s*)([ xX])(\s*\]\s*)(.*)$/; // prefix, mark, suffix, text
            let changed = false;

            for (let i = 0; i < lines.length; i++) {
              const m = lines[i].match(taskRe);
              if (!m) continue;
              const [ , prefix, mark, suffix, text ] = m;
              if (/[xX]/.test(mark)) continue;

              const norm = stripMd(text);
              const hitWanted = wanted.some(w => norm === w || norm.includes(w));
              const hitRegex  = regexes.some(r => r.test(text) || r.test(norm));

              if (hitWanted || hitRegex) {
                lines[i] = `${prefix}x${suffix}${text}`;
                changed = true;
              }
            }

            if (changed) {
              body = lines.join('\n');
              await github.rest.pulls.update({ owner, repo, pull_number: pr.number, body });
              core.info(`Checklist updated on PR #${pr.number}.`);
            } else {
              core.info('No matching checklist items found to tick.');
            }

            // ===== Ready gate (after any body update) =====
            // Collect *checked* task texts and normalize them for comparison
            const checkedTaskRe = /^[*\-]\s*\[\s*[xX]\s*\]\s*(.*)$/;
            const checkedRaw = (body || '').split(/\r?\n/)
              .map(l => (l.match(checkedTaskRe) || [])[1])
              .filter(Boolean);

            const checkedNorm = checkedRaw.map(stripMd);

            core.info(`Checked items (normalized): ${JSON.stringify(checkedNorm)}`);
            core.info(`Required items (normalized): ${JSON.stringify(required)}`);

            const allRequiredPresent = required.length === 0
              ? true
              : required.every(req => checkedNorm.some(ct => ct === req || ct.includes(req)));

            if (ready && requireAll && allRequiredPresent) {
              if (pr.draft) {
                await github.rest.pulls.update({ owner, repo, pull_number: pr.number, draft: false });
                core.info('All required items present — PR marked Ready for review.');
              } else {
                core.info('All required items present — PR already Ready.');
              }
            } else if (ready && requireAll && !allRequiredPresent) {
              core.info('Require-all is set, but not all required items are checked — staying Draft.');
            } // (if ready && !requireAll) callers aren’t using that mode here.

            // ===== Optional niceties (comment/label) — fully suppressed by default =====
            const comment = String(commentStr || '').trim();
            if (comment) {
              const existing = await github.paginate(github.rest.issues.listComments, {
                owner, repo, issue_number: pr.number, per_page: 100
              });
              if (!existing.some(c => (c.body || '').trim() === comment)) {
                await github.rest.issues.createComment({ owner, repo, issue_number: pr.number, body: comment }).catch(() => {});
              } else {
                core.info('Identical comment already exists; skipping duplicate.');
              }
            }

            const toRemove = String(removeLabelStr || '').trim();
            if (toRemove) {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: pr.number, name: toRemove }).catch(() => {});
            }
