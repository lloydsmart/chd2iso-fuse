name: Reusable — Update PR checklist ☑️

on:
  workflow_call:
    inputs:
      items:
        description: "Checklist items to tick (one per line; fuzzy match)"
        type: string
        required: true
      regex_items:
        description: "Optional regex matchers (one per line) to tick matching task lines"
        type: string
        default: ""
      comment:
        description: "Optional comment to post after updating checklist (off by default)"
        type: string
        default: ""
      remove_label:
        description: "Optional label to remove after updating checklist"
        type: string
        default: ""
      ready:
        description: "Attempt to set PR draft=false (Ready for review) after update"
        type: boolean
        default: false
      require_all:
        description: "Only flip to Ready if *all* required items are checked"
        type: boolean
        default: false
      required_items:
        description: "Required checklist items (one per line) that must be [x] to allow Ready flip"
        type: string
        default: ""

permissions:
  contents: read
  pull-requests: write

jobs:
  update:
    name: Tick checklist & update PR
    runs-on: ubuntu-latest
    steps:
      - name: ☑️ Update PR checklist
        uses: actions/github-script@v8
        with:
          script: |
            // ---------- helpers ----------
            function normalize(s){
              return String(s || '')
                // strip code/bold/italic/strike
                .replace(/`([^`]*)`/g, '$1')
                .replace(/\*\*([^*]+)\*\*/g, '$1')
                .replace(/\*([^*]+)\*/g, '$1')
                .replace(/__([^_]+)__/g, '$1')
                .replace(/_([^_]+)_/g, '$1')
                .replace(/~~([^~]+)~~/g, '$1')
                // drop emojis & HTML-ish bits
                .replace(/:[a-z0-9_+-]+:/gi, '')
                .replace(/<[^>]+>/g, '')
                // punctuation & bullets
                .replace(/[()[\]{}:;.,!?–—•·]|#+/g, ' ')
                .replace(/\s+/g, ' ')
                .trim()
                .toLowerCase();
            }
            function isReleaseOrHotfixBranch(name){
              return /^release\//.test(name) || /^hotfix\//.test(name);
            }

            const { owner, repo } = context.repo;

            // Resolve branch name reliably across pull_request / push / workflow_call
            const headRefFromPR = context.payload.pull_request?.head?.ref;
            const headRefEnv    = process.env.GITHUB_HEAD_REF;
            const refFromContext= (context.ref || '').replace(/^refs\/heads\//,'');
            const possibleHeads = [headRefFromPR, headRefEnv, refFromContext].filter(Boolean);
            const head = possibleHeads.find(isReleaseOrHotfixBranch) || possibleHeads[0];

            if (!head) { core.info('No head branch; skipping.'); return; }
            if (!isReleaseOrHotfixBranch(head)) {
              core.info(`Branch '${head}' is not release/* or hotfix/*; skipping.`);
              return;
            }

            // Find open PR for this branch
            const prs = await github.paginate(
              github.rest.pulls.list,
              { owner, repo, state: 'open', head: `${owner}:${head}`, per_page: 100 }
            );
            if (!prs.length) { core.info(`No open PR for ${owner}:${head}.`); return; }

            const pr = prs[0];

            // Inputs
            const itemsStr       = ${{ toJson(inputs.items) }};
            const regexItemsStr  = ${{ toJson(inputs.regex_items) }};
            const commentStr     = ${{ toJson(inputs.comment) }};
            const removeLabelStr = ${{ toJson(inputs.remove_label) }};
            const ready          = ${{ inputs.ready }};
            const requireAll     = ${{ inputs.require_all }};
            const requiredStr    = ${{ toJson(inputs.required_items) }};

            const wantedNorm = String(itemsStr).split(/\r?\n/).map(normalize).filter(Boolean);
            const regexes = String(regexItemsStr).split(/\r?\n/).map(s => s.trim()).filter(Boolean).map(p => {
              try { return new RegExp(p, 'i'); } catch { core.warning(`Bad regex skipped: ${p}`); return null; }
            }).filter(Boolean);
            const requiredNorm = String(requiredStr).split(/\r?\n/).map(normalize).filter(Boolean);

            // --- 1) Tick items in PR body -------------------------------------------------
            let body = pr.body || '';
            if (!body) core.info('PR has empty body; nothing to tick.');

            const lines = (body || '').split(/\r?\n/);
            const taskLine = /^([*\-]\s*\[\s*)([ xX])(\s*\]\s*)(.*)$/; // prefix, mark, suffix, text
            let changed = false;

            for (let i = 0; i < lines.length; i++) {
              const m = lines[i].match(taskLine);
              if (!m) continue;
              const [ , pre, mark, post, text ] = m;
              if (/[xX]/.test(mark)) continue;

              const norm = normalize(text);
              const hitWanted = wantedNorm.some(w => norm === w || norm.includes(w));
              const hitRegex  = regexes.some(r => r.test(text) || r.test(norm));

              if (hitWanted || hitRegex) {
                lines[i] = `${pre}x${post}${text}`;
                changed = true;
              }
            }

            if (changed) {
              body = lines.join('\n');
              await github.rest.pulls.update({ owner, repo, pull_number: pr.number, body });
              core.info(`Checklist updated on PR #${pr.number}.`);
              // Re-fetch PR to avoid any stale body/cache issues
              const fresh = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });
              body = fresh.data.body || body;
            } else {
              core.info('No matching checklist items found to tick.');
            }

            // --- 2) Decide Ready flip (require all) ---------------------------------------
            const checkedTask = /^[*\-]\s*\[\s*[xX]\s*\]\s*(.*)$/;
            const checkedRaw = (body || '').split(/\r?\n/)
              .map(l => (l.match(checkedTask) || [])[1])
              .filter(Boolean);
            const checkedNorm = checkedRaw.map(normalize);

            core.info(`Checked items (normalized): ${JSON.stringify(checkedNorm)}`);
            core.info(`Required items (normalized): ${JSON.stringify(requiredNorm)}`);

            let allRequiredPresent = true;
            if (requireAll) {
              if (requiredNorm.length === 0) {
                allRequiredPresent = false; // safety: don't flip with an empty requirement list
              } else {
                allRequiredPresent = requiredNorm.every(req =>
                  checkedNorm.some(ct => ct === req || ct.includes(req))
                );
              }
            }

            if (ready && (!requireAll || allRequiredPresent)) {
              if (pr.draft) {
                await github.rest.pulls.update({ owner, repo, pull_number: pr.number, draft: false });
                core.info('PR marked Ready for review.');
              } else {
                core.info('PR already Ready.');
              }
            } else if (ready && requireAll && !allRequiredPresent) {
              core.info('Require-all set but not all required items are checked — staying Draft.');
            }

            // --- 3) Optional (quiet by default) ------------------------------------------
            const comment = String(commentStr || '').trim();
            if (comment) {
              const existing = await github.paginate(github.rest.issues.listComments, {
                owner, repo, issue_number: pr.number, per_page: 100
              });
              if (!existing.some(c => (c.body || '').trim() === comment)) {
                await github.rest.issues.createComment({ owner, repo, issue_number: pr.number, body: comment }).catch(() => {});
              } else {
                core.info('Identical comment already exists; skipping duplicate.');
              }
            }
            const toRemove = String(removeLabelStr || '').trim();
            if (toRemove) {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: pr.number, name: toRemove }).catch(() => {});
            }
