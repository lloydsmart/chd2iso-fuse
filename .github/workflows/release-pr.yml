name: Auto-open PRs for release/hotfix branches 🔁

on:
  push:
    branches:
      - 'release/**'
      - 'hotfix/**'

permissions:
  contents: read
  pull-requests: write

jobs:
  open-prs:
    name: Create/ensure PRs exist (main + back-merge to develop)
    runs-on: ubuntu-latest
    steps:
      - name: 🧠 Derive names
        id: vars
        run: |
          echo "branch_ref=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"
          if [[ "${GITHUB_REF_NAME}" == release/* ]]; then
            echo "kind=release" >> "$GITHUB_OUTPUT"
          else
            echo "kind=hotfix" >> "$GITHUB_OUTPUT"
          fi

      - name: 🧰 Create/ensure PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Branch + kind
            const branch = core.getInput('branch') || process.env.GITHUB_REF_NAME;
            const kind = branch.startsWith('release/') ? 'release' : 'hotfix';

            // Helper to find an open PR by head/base
            async function findPr(head, base) {
              const { data } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: `${context.repo.owner}:${head}`,
                base
              });
              return data[0];
            }

            // ===== Release PR → main (draft with 3 unchecked boxes) =====
            let releasePr = await findPr(branch, 'main');
            if (!releasePr) {
              const title = kind === 'release'
                ? 'Release: ' + branch.replace(/^release\//, '')
                : 'Hotfix: '  + branch.replace(/^hotfix\//, '');

              const body = [
                `This ${kind} PR is auto-created for branch \`${branch}\`.`,
                ``,
                `### ✅ Release readiness checklist`,
                `- [ ] CI build & tests passed`,
                `- [ ] Version bump & changelog completed`,
                `- [ ] CodeQL security scan completed`,
                ``,
                `_This PR was created automatically. The checklist will be updated by workflows without comments._`
              ].join('\n');

              const { data } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                head: branch,
                base: 'main',
                body,
                draft: true
              });
              releasePr = data;
              core.info(`Created release PR #${releasePr.number} -> main`);
            } else {
              core.info(`Release PR already exists: #${releasePr.number}`);
            }

            core.setOutput('release_pr_number', String(releasePr.number));

            // ===== Back-merge PR → develop (only if head is ahead of base) =====
const baseBranch = 'develop';

// Compare commits to avoid 422 when there's nothing to merge
const cmp = await github.rest.repos.compareCommits({
  owner: context.repo.owner,
  repo: context.repo.repo,
  base: baseBranch,
  head: branch
});
core.info(`Compare ${branch} vs ${baseBranch}: ahead_by=${cmp.data.ahead_by}, behind_by=${cmp.data.behind_by}, status=${cmp.data.status}`);

let backPr = await findPr(branch, baseBranch);

if (cmp.data.ahead_by > 0) {
  if (!backPr) {
    const title = `Back-merge ${branch} → ${baseBranch}`;
    const body  = `Automated back-merge PR from \`${branch}\` to \`${baseBranch}\`. Auto-merge is enabled when checks pass.`;
    const { data } = await github.rest.pulls.create({
      owner: context.repo.owner,
      repo: context.repo.repo,
      title,
      head: branch,
      base: baseBranch,
      body,
      draft: false
    });
    backPr = data;
    core.info(`Created back-merge PR #${backPr.number} -> ${baseBranch}`);
  } else {
    core.info(`Back-merge PR already exists: #${backPr.number}`);
  }

  // Try to enable auto-merge for the back-merge PR (GraphQL)
  try {
    const mutation = `
      mutation($prId:ID!) {
        enablePullRequestAutoMerge(input:{
          pullRequestId:$prId,
          mergeMethod: MERGE
        }) { clientMutationId }
      }
    `;
    await github.graphql(mutation, { prId: backPr.node_id });
    core.info(`Auto-merge enabled for PR #${backPr.number}`);
  } catch (e) {
    core.warning(`Could not enable auto-merge for PR #${backPr.number}. Ensure repository auto-merge is enabled. ${e.message}`);
  }
} else {
  if (backPr) {
    core.info(`Back-merge PR #${backPr.number} exists but compare shows no commits ahead; consider closing if redundant.`);
  } else {
    core.info(`No back-merge PR created: ${branch} has no commits ahead of ${baseBranch}.`);
  }
}
// Try to enable auto-merge for the back-merge PR (GraphQL)
            try {
              const mutation = `
                mutation($prId:ID!) {
                  enablePullRequestAutoMerge(input:{
                    pullRequestId:$prId,
                    mergeMethod: MERGE
                  }) { clientMutationId }
                }
              `;
              await github.graphql(mutation, { prId: backPr.node_id });
              core.info(`Auto-merge enabled for PR #${backPr.number}`);
            } catch (e) {
              core.warning(`Could not enable auto-merge for PR #${backPr.number}. Ensure repository auto-merge is enabled. ${e.message}`);
            }
