name: Build & (on tag) Release – Debian Trixie

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  pull_request:
  workflow_dispatch:
  schedule:
    - cron: "15 8 * * 1-5"   # Weekdays 08:15 Europe/London

permissions:
  contents: write
  actions: read
  pull-requests: write
  issues: write

# Cancel older in-flight runs on the same ref
concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: true

jobs:
  uscan-check:
    name: Watch upstream (uscan)
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout (with tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install devscripts (for uscan)
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends devscripts ca-certificates

      - name: Run uscan
        id: uscan
        run: |
          set -euo pipefail
          uscan --dehs --verbose --timeout 30 | tee uscan.xml
          if grep -q '<status>newer</status>' uscan.xml; then
            ver=$(grep -oPm1 '(?<=<upstream-version>)[^<]+' uscan.xml || echo unknown)
            echo "newer=true" >> "$GITHUB_OUTPUT"
            echo "version=$ver" >> "$GITHUB_OUTPUT"
          else
            echo "newer=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create issue if newer upstream
        if: steps.uscan.outputs.newer == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const ver = '${{ steps.uscan.outputs.version }}';
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `New upstream release detected: ${ver}`,
              body: [
                `uscan detected a newer upstream release **${ver}**.`,
                ``,
                `Next steps:`,
                `1) Update \`debian/changelog\` (e.g. \`dch -v ${ver}-1 "New upstream release"\`).`,
                `2) Build per suite (sbuild for bookworm/trixie).`,
                `3) Add to aptly repo and publish snapshot.`,
              ].join('\n'),
              labels: ['uscan', 'packaging']
            });

  build-debs:
    name: Build .deb (always)
    runs-on: ubuntu-latest
    container:
      image: debian:trixie
      options: --init
    defaults:
      run:
        shell: bash
    env:
      GIT_CLIFF_VERSION: ${{ secrets.GIT_CLIFF_VERSION || '2.9.1' }}
      RUSTC_WRAPPER: sccache
      SCCACHE_DIR: ${{ github.workspace }}/.sccache
      SCCACHE_CACHE_SIZE: 2G
      RUSTFLAGS: "--remap-path-prefix=${{ github.workspace }}=."
      DEBFULLNAME: "Lloyd Smart"
      DEBEMAIL: "lloydsmart@users.noreply.github.com"
      EMAIL: "lloydsmart@users.noreply.github.com"

    steps:
      - name: Install git for checkout
        run: |
          set -e
          apt-get update
          DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends git ca-certificates

      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
          fetch-tags: true

      - name: Configure git trust and identity
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git config --global user.name "Lloyd Smart"
          git config --global user.email "lloydsmart@users.noreply.github.com"

      - name: Debug event info
        run: |
          echo "event_name=${GITHUB_EVENT_NAME}"
          echo "ref=${GITHUB_REF}"
          echo "ref_name=${GITHUB_REF_NAME}"
          git describe --tags --always || true

      - name: Install build deps (no Rust from apt)
        run: |
          set -e
          apt-get update
          DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
            build-essential pkg-config \
            libfuse3-dev fuse3 \
            clang \
            devscripts debhelper dh-cargo lintian \
            git-buildpackage \
            sccache \
            curl jq ca-certificates \
            gnupg dirmngr

      - name: Add ~/.cargo/bin to PATH
        run: echo "$HOME/.cargo/bin" >> "$GITHUB_PATH"

      - name: Install Rust toolchain (pinned)
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.86.0
          components: rustfmt, clippy

      - name: Ensure helper scripts are executable
        run: |
          chmod +x scripts/gen-debian-changelog.sh
          chmod +x scripts/gen-release-notes.sh
          chmod +x scripts/set-cargo-version.sh

      - name: Detect rustc version
        id: rustver
        run: echo "ver=$(rustc -V | awk '{print $2}')" >> "$GITHUB_OUTPUT"

      - name: Compute Cargo.lock hash (safe)
        id: cargo_lock_hash
        run: |
          set -e
          if find . -name Cargo.lock -type f | grep -q .; then
            sha=$(find . -name Cargo.lock -type f -print0 | sort -z | xargs -0 cat | sha256sum | cut -d' ' -f1)
            echo "hash=$sha" >> "$GITHUB_OUTPUT"
          else
            echo "hash=none" >> "$GITHUB_OUTPUT"
          fi

      - name: Compute SOURCE_DATE_EPOCH from HEAD
        id: sde
        run: echo "epoch=$(git log -1 --format=%ct)" >> "$GITHUB_OUTPUT"

      - name: Ensure sccache dir exists and show path
        run: |
          mkdir -p "${SCCACHE_DIR}"
          echo "SCCACHE_DIR=${SCCACHE_DIR}"

      - name: Cache sccache store
        uses: actions/cache@v4
        with:
          path: ${{ env.SCCACHE_DIR }}
          key: sccache-${{ runner.os }}-${{ steps.cargo_lock_hash.outputs.hash }}-rust-${{ steps.rustver.outputs.ver }}
          restore-keys: |
            sccache-${{ runner.os }}-

      - name: Cache cargo registry & target
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: cargo-${{ runner.os }}-${{ steps.cargo_lock_hash.outputs.hash }}-rust-${{ steps.rustver.outputs.ver }}
          restore-keys: |
            cargo-${{ runner.os }}-

      - name: Cache git-cliff binary
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/git-cliff
          key: git-cliff-bin-${{ runner.os }}-${{ env.GIT_CLIFF_VERSION }}

      - name: Install git-cliff (pinned)
        run: |
          echo "Installing git-cliff ${GIT_CLIFF_VERSION}"
          if ! command -v git-cliff >/dev/null 2>&1; then
            cargo install git-cliff --version "${GIT_CLIFF_VERSION}"
          fi

      - name: sccache zero-stats
        run: sccache --zero-stats || true

      # --- Release-only changelog generation & guards ---
      - name: Derive version from tag
        if: startsWith(github.ref, 'refs/tags/')
        id: ver
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "debver=${VERSION}-1" >> "$GITHUB_OUTPUT"

      - name: Sync Cargo.toml version from tag (no cargo-edit)
        if: startsWith(github.ref, 'refs/tags/')
        env:
          VERSION: ${{ steps.ver.outputs.version }}
        run: |
          set -euo pipefail
          scripts/set-cargo-version.sh "$VERSION"
          rm -f Cargo.toml.bak
          git add Cargo.toml
          git commit -m "chore(release): set Cargo version to $VERSION from tag" || true

      - name: "Verify Cargo.toml updated to tag version"
        if: startsWith(github.ref, 'refs/tags/')
        env:
          EXPECT: ${{ steps.ver.outputs.version }}  # already stripped of 'v' above
        run: |
          set -euo pipefail
          # Normalize just in case future changes pass a v-prefixed string
          EXPECT_NOV="${EXPECT#v}"
          ACTUAL="$(sed -n 's/^version[[:space:]]*=[[:space:]]*"\(.*\)"/\1/p' Cargo.toml | head -n1)"
          echo "Cargo.toml: expected=${EXPECT_NOV} actual=${ACTUAL}"
          [ "$ACTUAL" = "$EXPECT_NOV" ] || {
            echo "ERROR: Cargo.toml not updated"
            git --no-pager diff -- Cargo.toml || true
            exit 1
          }

      - name: Rewrite Cargo.lock to reflect new package version (offline)
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          set -eu
          cargo generate-lockfile --offline
          git status --porcelain || true

      - name: Commit lockfile after version bump
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          set -eu
          git add Cargo.lock
          git commit -m "chore(release): sync Cargo.lock to version ${{ steps.ver.outputs.version }}" || true

      - name: "Show Cargo.toml diff"
        if: startsWith(github.ref, 'refs/tags/')
        run: git --no-pager diff -- Cargo.toml || true

      - name: Generate Debian changelog (gbp dch -> dch --newversion)
        if: startsWith(github.ref, 'refs/tags/')
        env:
          TAG: ${{ github.ref_name }}
        run: scripts/gen-debian-changelog.sh "$TAG" trixie

      - name: Verify Debian version matches tag (pre-build)
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          set -eu
          EXPECT="${{ steps.ver.outputs.debver }}"
          ACTUAL="$(dpkg-parsechangelog -SVersion)"
          echo "PRE-BUILD: expected=${EXPECT} actual=${ACTUAL}"
          sed -n '1,20p' debian/changelog || true
          [ "${ACTUAL}" = "${EXPECT}" ]

      - name: Generate CHANGELOG.md + RELEASE_NOTES.md (git-cliff)
        if: startsWith(github.ref, 'refs/tags/')
        run: scripts/gen-release-notes.sh artifacts

      # --- Build & package ---
      - name: Verify Cargo.lock is present
        run: |
          test -f Cargo.lock || { echo "ERROR: Cargo.lock missing. Commit it to the repo."; exit 1; }

      - name: cargo fetch (locked)
        run: cargo fetch --locked

      - name: Validate lockfile consistency (offline, fail fast)
        run: |
          set -eu
          cargo metadata --locked --offline --format-version=1 -q > /dev/null

      - name: "Build release binary (for sanity check)"
        env:
          RUSTC_WRAPPER: ${{ env.RUSTC_WRAPPER }}
          SCCACHE_DIR: ${{ env.SCCACHE_DIR }}
          SOURCE_DATE_EPOCH: ${{ steps.sde.outputs.epoch }}
        run: cargo build --release --locked

      - name: "Sanity check: binary --version matches Cargo.toml"
        run: |
          set -euo pipefail
          # Extract Cargo package version (first match only)
          CARGO_VERSION="$(sed -n 's/^version[[:space:]]*=[[:space:]]*"\(.*\)"/\1/p' Cargo.toml | head -n1)"
          echo "Cargo.toml version: ${CARGO_VERSION}"

          # Run the freshly built binary
          BIN="./target/release/chd2iso-fuse"
          test -x "$BIN"
          BIN_VERSION="$("$BIN" --version | awk '{print $2}')"
          echo "Binary --version: ${BIN_VERSION}"

          if [ "$BIN_VERSION" != "$CARGO_VERSION" ]; then
            echo "ERROR: Binary version (${BIN_VERSION}) != Cargo.toml version (${CARGO_VERSION})"
            exit 1
          fi

          # On tagged builds, also assert it matches the tag’s version
          if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
            TAG_VERSION="${{ steps.ver.outputs.version }}"
            echo "Tag version: ${TAG_VERSION}"
            [ "$BIN_VERSION" = "$TAG_VERSION" ] || { echo "ERROR: Binary version != tag version"; exit 1; }
          fi

      - name: Build .deb with debuild
        env:
          RUSTC_WRAPPER: ${{ env.RUSTC_WRAPPER }}
          SCCACHE_DIR: ${{ env.SCCACHE_DIR }}
          SCCACHE_RECACHE: "1"
          SOURCE_DATE_EPOCH: ${{ steps.sde.outputs.epoch }}
        run: debuild -us -uc -b

      - name: "Sanity check: binary inside .deb reports expected version"
        run: |
          set -euo pipefail

          # Gather expected versions
          CARGO_VERSION="$(sed -n 's/^version[[:space:]]*=[[:space:]]*"\(.*\)"/\1/p' Cargo.toml | head -n1)"
          DEB_VERSION="$(dpkg-parsechangelog -SVersion || echo '0.0.0-0')"
          UPSTREAM_VERSION="${DEB_VERSION%%-*}"

          echo "Cargo version:    ${CARGO_VERSION}"
          echo "Debian version:   ${DEB_VERSION}"
          echo "Upstream version: ${UPSTREAM_VERSION}"

          # Find the .deb we just built (main binary)
          DEB_FILE="$(ls -1 ../chd2iso-fuse_*_amd64.deb | head -n1)"
          echo "Checking .deb: ${DEB_FILE}"

          TMPDIR="$(mktemp -d)"
          dpkg-deb -x "$DEB_FILE" "$TMPDIR"
          BIN="$TMPDIR/usr/bin/chd2iso-fuse"
          test -x "$BIN"

          BIN_VERSION="$("$BIN" --version | awk '{print $2}')"
          echo "Binary in .deb --version: ${BIN_VERSION}"

          # Always enforce: binary matches Cargo.toml
          [ "$BIN_VERSION" = "$CARGO_VERSION" ] || { echo "ERROR: .deb binary version != Cargo.toml"; exit 1; }

          # Enforce Debian upstream only when appropriate:
          # - on tagged builds (release path), OR
          # - when changelog upstream already equals Cargo.toml (they're in sync)
          ENFORCE_DEB=false
          if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
            ENFORCE_DEB=true
          elif [[ "$UPSTREAM_VERSION" = "$CARGO_VERSION" ]]; then
            ENFORCE_DEB=true
          fi

          if $ENFORCE_DEB; then
            [ "$BIN_VERSION" = "$UPSTREAM_VERSION" ] || { 
              echo "ERROR: .deb binary version != Debian upstream version"; 
              exit 1; 
            }
          else
            echo "Note: skipping Debian-upstream match on non-tag build because Cargo.toml (${CARGO_VERSION}) != debian/changelog upstream (${UPSTREAM_VERSION})."
          fi

          # On tagged builds, also assert it matches the tag
          if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
            TAG_VERSION="${GITHUB_REF_NAME#v}"
            echo "Tag version: ${TAG_VERSION}"
            [ "$BIN_VERSION" = "$TAG_VERSION" ] || { echo "ERROR: .deb binary version != tag version"; exit 1; }
          fi

      - name: Assert Cargo.lock unchanged by build
        run: |
          git diff --exit-code -- Cargo.lock || { echo "ERROR: Cargo.lock was modified during the build."; exit 1; }

      - name: Show produced files (parent dir)
        run: |
          echo "Parent directory after build:"
          ls -l .. | sed -n '1,200p' || true

      - name: "Guard: built files for expected deb version must exist"
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          set -eu
          VER_EXPECT="${{ steps.ver.outputs.debver }}"
          echo "POST-BUILD: expecting files containing _${VER_EXPECT}_"
          if ! find .. -maxdepth 1 -type f \
               \( -name "*_${VER_EXPECT}_*.deb" -o -name "*_${VER_EXPECT}_*.buildinfo" -o -name "*_${VER_EXPECT}_*.changes" \) \
               | grep -q .; then
            echo "ERROR: No files for ${VER_EXPECT} were built."
            sed -n '1,20p' debian/changelog || true
            exit 1
          fi

      - name: Collect artifacts (tagged build; auto-detect by version)
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          set -eu
          mkdir -p artifacts
          VER="$(dpkg-parsechangelog -SVersion)"
          echo "Collecting *_${VER}_* from parent dir…"
          find .. -maxdepth 1 -type f \( -name "*_${VER}_*.deb" -o -name "*_${VER}_*.buildinfo" -o -name "*_${VER}_*.changes" \) -print0 \
            | xargs -0 -I{} mv "{}" artifacts/
          test -f artifacts/RELEASE_NOTES.md || echo "(tag build – notes elsewhere)" > artifacts/RELEASE_NOTES.md
          ls -l artifacts || true

      - name: Collect artifacts (non-tag)
        if: ${{ !startsWith(github.ref, 'refs/tags/') }}
        run: |
          set -e
          mkdir -p artifacts
          mv ../chd2iso-fuse_*_amd64.deb artifacts/ || true
          mv ../chd2iso-fuse-dbgsym_*_amd64.deb artifacts/ || true
          mv ../chd2iso-fuse_*_amd64.buildinfo artifacts/ || true
          mv ../chd2iso-fuse_*_amd64.changes artifacts/ || true
          test -f artifacts/RELEASE_NOTES.md || echo "(build from branch/PR – no tagged release notes)" > artifacts/RELEASE_NOTES.md
          ls -l artifacts || true

      - name: Create SHA256SUMS for artifacts
        run: |
          set -e
          shopt -s nullglob
          if [ -d artifacts ]; then
            (
              cd artifacts
              files=( *.deb *.buildinfo *.changes )
              if [ ${#files[@]} -gt 0 ]; then
                sha256sum "${files[@]}" > SHA256SUMS
                echo "SHA256SUMS created:"
                sed -n '1,200p' SHA256SUMS
              else
                echo "No .deb/.buildinfo/.changes in artifacts/; skipping SHA256SUMS."
              fi
            )
          else
            echo "artifacts/ directory not found; skipping SHA256SUMS."
          fi

      - name: Import GPG signing key (if provided)
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${GPG_PRIVATE_KEY:-}" ]; then
            echo "No GPG_PRIVATE_KEY secret set; skipping import."
            exit 0
          fi
          export GNUPGHOME="$GITHUB_WORKSPACE/.gnupg"
          mkdir -p "$GNUPGHOME"; chmod 700 "$GNUPGHOME"
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          KEYID=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec/ {print $5; exit}')
          echo -e "5\ny\n" | gpg --command-fd 0 --batch --yes --edit-key "$KEYID" trust quit
          echo "GPG_KEYID=$KEYID" >> "$GITHUB_ENV"

      - name: Sign SHA256SUMS (armored, detached if key present)
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          export GNUPGHOME="$GITHUB_WORKSPACE/.gnupg"
          if [ ! -f artifacts/SHA256SUMS ]; then
            echo "No SHA256SUMS to sign; skipping."
            exit 0
          fi
          if [ ! -s "$GNUPGHOME/pubring.kbx" ]; then
            echo "No private key imported; skipping signing."
            exit 0
          fi
          KEYID=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec/ {print $5; exit}')
          (
            cd artifacts
            gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
                --armor --detach-sign --local-user "$KEYID" \
                --output SHA256SUMS.asc SHA256SUMS
            echo "Created artifacts/SHA256SUMS.asc"
            gpg --verify SHA256SUMS.asc SHA256SUMS
          )

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: chd2iso-fuse-debs
          path: artifacts/*
          if-no-files-found: error
          retention-days: 14

      - name: Prepare CHANGELOG update (copy into repo)
        if: startsWith(github.ref, 'refs/tags/')
        run: cp artifacts/CHANGELOG.md CHANGELOG.md

      - name: Create PR to update CHANGELOG.md, debian/changelog, Cargo.toml on main
        if: startsWith(github.ref, 'refs/tags/')
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          base: main
          branch: chore/update-changelogs-${{ github.ref_name }}
          title: "chore(release): update changelogs for ${{ github.ref_name }}"
          body: |
            Automated PR to update CHANGELOG.md, debian/changelog, and Cargo.toml for ${{ github.ref_name }}.
            - `CHANGELOG.md` generated by git-cliff
            - `debian/changelog` generated by gbp dch / dch
            - `Cargo.toml` version set from tag
          commit-message: "chore(release): update CHANGELOG.md, debian/changelog, and Cargo.toml for ${{ github.ref_name }}"
          add-paths: |
            CHANGELOG.md
            debian/changelog
            Cargo.toml
            Cargo.lock
          delete-branch: true
          labels: |
            automated
            changelog

  publish-release:
    name: Publish GitHub Release (only on tag)
    runs-on: ubuntu-latest
    needs: build-debs
    if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/') && needs['build-debs'].result == 'success' }}
    steps:
      - name: Debug event info
        run: |
          echo "event_name=${GITHUB_EVENT_NAME}"
          echo "ref=${GITHUB_REF}"
          echo "ref_name=${GITHUB_REF_NAME}"

      - name: Download build artifacts
        uses: actions/download-artifact@v5
        with:
          name: chd2iso-fuse-debs
          path: .

      - name: List downloaded artifacts & guard
        shell: bash
        run: |
          echo "Looking for release assets in workspace:"
          find . -maxdepth 2 -type f \( -name "*.deb" -o -name "*.buildinfo" -o -name "*.changes" -o -name "CHANGELOG.md" -o -name "SHA256SUMS" -o -name "SHA256SUMS.asc" \) -printf '%P\n' | sort || true
          shopt -s nullglob globstar
          deb=(**/*.deb); bi=(**/*.buildinfo); ch=(**/*.changes)
          if [ ${#deb[@]} -eq 0 ] && [ ${#bi[@]} -eq 0 ] && [ ${#ch[@]} -eq 0 ]; then
            echo "No .deb/.buildinfo/.changes files found anywhere after download."
            exit 1
          fi

      - name: Ensure RELEASE_NOTES.md is present in repo root
        shell: bash
        run: |
          if [ -f RELEASE_NOTES.md ]; then
            echo "Using RELEASE_NOTES.md from repo root."
          elif [ -f artifacts/RELEASE_NOTES.md ]; then
            echo "Moving artifacts/RELEASE_NOTES.md -> RELEASE_NOTES.md"
            mv artifacts/RELEASE_NOTES.md RELEASE_NOTES.md
          elif [ -f CHANGELOG.md ]; then
            echo "No release notes found; copying CHANGELOG.md -> RELEASE_NOTES.md"
            cp CHANGELOG.md RELEASE_NOTES.md
          else
            echo "(no release notes provided)" > RELEASE_NOTES.md
          fi

      - name: Assemble release asset list
        id: assets
        shell: bash
        run: |
          set -e
          shopt -s nullglob
          files=()
          for f in *.deb *.buildinfo *.changes CHANGELOG.md SHA256SUMS SHA256SUMS.asc; do
            [ -e "$f" ] && files+=("$f")
          done
          if [ ${#files[@]} -eq 0 ]; then
            echo "No candidate assets in repo root." >&2
            ls -la
            exit 1
          fi
          echo "Will upload:"
          printf '  - %s\n' "${files[@]}"
          {
            echo 'ASSET_FILES<<EOF'
            printf '%s\n' "${files[@]}"
            echo 'EOF'
          } >> "$GITHUB_ENV"

      - name: Check if release already exists
        id: check_release
        uses: actions/github-script@v7
        env:
          EXPECT_ASC: ${{ env.EXPECT_ASC }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tag = process.env.GITHUB_REF_NAME || context.ref.replace('refs/tags/','');
            const expectAsc = (process.env.EXPECT_ASC || 'false') === 'true';
            let exists = false, draft = false, assets_ok = false;
            try {
              const res = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag
              });
              exists = true;
              draft = !!res.data.draft;
              const assets = res.data.assets || [];
              const hasDeb = assets.some(a => a.name.endsWith('.deb'));
              const hasBuildinfo = assets.some(a => a.name.endsWith('.buildinfo'));
              const hasChanges = assets.some(a => a.name.endsWith('.changes'));
              const hasSums = assets.some(a => a.name === 'SHA256SUMS');
              const hasAsc = assets.some(a => a.name === 'SHA256SUMS.asc');
              assets_ok = hasDeb && hasBuildinfo && hasChanges && hasSums && (!expectAsc || hasAsc);
              core.info(`Release exists (draft=${draft}); assets_ok=${assets_ok}; expectAsc=${expectAsc}; assets=[${assets.map(a=>a.name).join(', ')}]`);
            } catch (e) {
              if (e.status !== 404) throw e;
              core.info(`No release for tag ${tag}.`);
            }
            core.setOutput('exists', String(exists));
            core.setOutput('draft', String(draft));
            core.setOutput('assets_ok', String(assets_ok));

      - name: "Create draft release & upload assets"
        if: ${{ steps.check_release.outputs.exists != 'true' || steps.check_release.outputs.draft == 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: chd2iso-fuse ${{ github.ref_name }}
          body_path: RELEASE_NOTES.md
          generate_release_notes: false
          draft: true
          fail_on_unmatched_files: false
          files: ${{ env.ASSET_FILES }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: "Publish release (flip draft -> published)"
        if: ${{ steps.check_release.outputs.exists != 'true' || steps.check_release.outputs.draft == 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          draft: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Fail if published release is missing assets (immutable blocks uploads)
        if: ${{ steps.check_release.outputs.exists == 'true' && steps.check_release.outputs.draft != 'true' && steps.check_release.outputs.assets_ok != 'true' }}
        run: |
          echo "A published release already exists for '${GITHUB_REF_NAME}' but is missing required assets (.deb/.buildinfo/.changes/SHA256SUMS and optional SHA256SUMS.asc)."
          echo "Recreate the release (keep the tag) and re-run this job."
          exit 1

      - name: Verify assets attached to release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tag = process.env.GITHUB_REF_NAME || (context.ref || '').replace('refs/tags/', '');
            try {
              const res = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag
              });
              const assets = Array.isArray(res.data.assets) ? res.data.assets : [];
              core.info(`Release assets: ${assets.map(a => a.name).join(', ') || '(none)'}`);
              if (assets.length === 0) {
                core.setFailed('Release has no assets attached.');
              }
            } catch (e) {
              if (e.status === 404) {
                core.setFailed(`Release for tag ${tag} not found.`);
              } else {
                throw e;
              }
            }
