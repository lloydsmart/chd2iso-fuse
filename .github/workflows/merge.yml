name: On merge to main (release/hotfix) üîóü§ù

on:
  push:
    branches: [ main ]

concurrency:
  group: on-merge-${{ github.ref }}
  cancel-in-progress: false

jobs:
  detect:
    name: üîé Detect merged PR
    if: "!contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]')"
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
      contents: read
    outputs:
      is_release: ${{ steps.out.outputs.is_release }}
      head_ref:   ${{ steps.out.outputs.head_ref }}
      pr_number:  ${{ steps.out.outputs.pr_number }}
    steps:
      - id: out
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const commitSha = context.payload?.head_commit?.id || context.sha;

            async function findByCommitSha() {
              for (let i = 0; i < 5; i++) {
                const prs = await github.paginate(
                  github.rest.repos.listPullRequestsAssociatedWithCommit,
                  { owner, repo, commit_sha: commitSha, per_page: 100 }
                );
                const pr = prs.find(p => p.merged_at && p.base?.ref === 'main');
                if (pr) return pr;
                await new Promise(r => setTimeout(r, 2000));
              }
              return null;
            }

            async function fallbackRecentMerged() {
              const closed = await github.paginate(github.rest.pulls.list, {
                owner, repo, state: 'closed', base: 'main', per_page: 50, sort: 'updated', direction: 'desc'
              });
              return closed.find(p =>
                p.merged_at &&
                (p.head?.ref?.startsWith('release/') || p.head?.ref?.startsWith('hotfix/'))
              ) || null;
            }

            const pr = await findByCommitSha() || await fallbackRecentMerged();
            const headRef = pr?.head?.ref || '';
            const isRelease = Boolean(pr && (headRef.startsWith('release/') || headRef.startsWith('hotfix/')));

            core.setOutput('is_release', String(isRelease));
            core.setOutput('head_ref', headRef);
            core.setOutput('pr_number', pr?.number ?? '');
            core.info(pr
              ? `Using PR #${pr.number} from '${headRef}' (merged_at=${pr.merged_at})`
              : 'No merged PR into main found (detect)');

  verify:
    name: üîç Verify versions (Cargo / Debian / binary)
    needs: detect
    if: needs.detect.outputs.is_release == 'true'
    permissions:
      contents: read
    uses: ./.github/workflows/_verify-release.yml
    secrets: inherit

  tag:
    name: üè∑Ô∏è Create signed annotated tag vX.Y.Z
    needs: [detect, verify]
    if: needs.detect.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: ‚úÖ Preflight check (vars + secrets present)
        env:
          HAS_GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY != '' }}
          HAS_GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE != '' }}
          HAS_AUTHOR_NAME: ${{ vars.GIT_AUTHOR_NAME != '' }}
          HAS_AUTHOR_EMAIL: ${{ vars.GIT_AUTHOR_EMAIL != '' }}
          HAS_RELEASE_PAT: ${{ secrets.RELEASE_PAT != '' }}
        run: |
          set -euo pipefail
          missing=0
          if [ "${HAS_GPG_PRIVATE_KEY}" != "true" ]; then echo "::error::Secret GPG_PRIVATE_KEY is missing!"; missing=1; fi
          if [ "${HAS_GPG_PASSPHRASE}" != "true" ]; then echo "::error::Secret GPG_PASSPHRASE is missing!"; missing=1; fi
          if [ "${HAS_RELEASE_PAT}" != "true" ]; then echo "::error::Secret RELEASE_PAT is missing (required to trigger release)!"; missing=1; fi
          if [ "${HAS_AUTHOR_NAME}" != "true" ]; then echo "::warning::Variable GIT_AUTHOR_NAME is not set (will use default)."; fi
          if [ "${HAS_AUTHOR_EMAIL}" != "true" ]; then echo "::warning::Variable GIT_AUTHOR_EMAIL is not set (will use default)."; fi
          if [ $missing -eq 1 ]; then echo "Required secrets missing; cannot proceed."; exit 1; fi

      - name: üì• Checkout main
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: üîè Ensure safe git dir
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: üë§ Configure git identity (from Actions Variables)
        run: |
          set -euo pipefail
          NAME="${{ vars.GIT_AUTHOR_NAME }}"
          EMAIL="${{ vars.GIT_AUTHOR_EMAIL }}"
          : "${NAME:=Release Bot}"
          : "${EMAIL:=release-bot@users.noreply.github.com}"
          git config user.name  "${NAME}"
          git config user.email "${EMAIL}"
          git config commit.gpgsign true
          git config tag.gpgSign true
          echo "Using git identity: ${NAME} <${EMAIL}>"

      - name: üîê Import GPG private key
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          gpgconf --kill gpg-agent
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          FPR="$(gpg --batch --list-secret-keys --with-colons | awk -F: '/^fpr:/ {print $10; exit}')"
          if [ -z "$FPR" ]; then echo "No secret key fingerprint found after import"; exit 1; fi
          echo "FPR=$FPR" >> "$GITHUB_ENV"
          git config user.signingkey "$FPR"

      - name: üõ†Ô∏è Install GPG wrapper for non-interactive signing
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          cat > "$GITHUB_WORKSPACE/gpg-wrapper.sh" <<'EOF'
          #!/usr/bin/env bash
          exec gpg --batch --pinentry-mode loopback --passphrase "${GPG_PASSPHRASE}" "$@"
          EOF
          chmod +x "$GITHUB_WORKSPACE/gpg-wrapper.sh"
          git config gpg.program "$GITHUB_WORKSPACE/gpg-wrapper.sh"

      - name: üß™ GPG sanity check (non-interactive)
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: echo "ok" | gpg --batch --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --clearsign >/dev/null

      - name: üìñ Read version from Cargo.toml
        id: ver
        run: |
          set -euo pipefail
          ver="$(sed -n 's/^version[[:space:]]*=[[:space:]]*"\(.*\)".*/\1/p' Cargo.toml | head -n1)"
          [[ -n "$ver" ]] || { echo "No version in Cargo.toml"; exit 1; }
          [[ "$ver" != *-dev* ]] || { echo "Version has -dev suffix; refusing to tag"; exit 1; }
          echo "val=$ver" >> "$GITHUB_OUTPUT"
          echo "Version: $ver"

      - name: üè∑Ô∏è Create & push signed tag (with PAT so Release workflow triggers)
        env:
          VER: ${{ steps.ver.outputs.val }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          RELEASE_PAT: ${{ secrets.RELEASE_PAT }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          tag="v${VER}"

          # Skip if tag already on remote
          if git ls-remote --tags origin "refs/tags/${tag}" | grep -q .; then
            echo "Tag ${tag} already exists on origin; nothing to do."
            exit 0
          fi

          export GPG_TTY=$(tty || true)
          git tag -s "${tag}" -m "chd2iso-fuse ${tag}"
          git tag -v "${tag}"

          # Use PAT so the tag push triggers `on: push` workflows
          git remote set-url origin "https://x-access-token:${RELEASE_PAT}@github.com/${REPO}.git"
          git push origin "refs/tags/${tag}"
          echo "Pushed signed tag ${tag} with PAT (should trigger Release workflow)"

      - name: üöÄ Dispatch Release workflow for this tag (fallback)
        env:
          RELEASE_PAT: ${{ secrets.RELEASE_PAT }}
          REPO: ${{ github.repository }}
          TAG: v${{ steps.ver.outputs.val }}
        run: |
          set -euo pipefail
          echo "Dispatching release.yml for TAG=${TAG}"
          resp=$(curl -sS -o /tmp/resp.txt -w "%{http_code}" -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${RELEASE_PAT}" \
            "https://api.github.com/repos/${REPO}/actions/workflows/release.yml/dispatches" \
            -d "{\"ref\":\"main\",\"inputs\":{\"tag\":\"${TAG}\"}}")
          if [ "$resp" != "204" ]; then
            echo "::warning::Release dispatch returned HTTP ${resp}"
            sed -n '1,200p' /tmp/resp.txt || true
          else
            echo "Dispatched release.yml for ${TAG}"
          fi

  backmerge:
    name: üîÅ Open back-merge PR (main -> develop)
    needs: [detect]  # decoupled from tag so it still runs if tagging is skipped/failed
    if: needs.detect.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      checks: read
    steps:
      - name: üîç Compare branches (is develop behind main?)
        id: compare
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const res = await github.rest.repos.compareCommits({
              owner, repo, base: 'develop', head: 'main'
            });
            core.setOutput('status', res.data.status);
            core.setOutput('ahead_by', String(res.data.ahead_by));
            core.setOutput('behind_by', String(res.data.behind_by));

      - name: üßæ Log compare result
        run: |
          echo "Compare status: ${{ steps.compare.outputs.status }}"
          echo "ahead_by:      ${{ steps.compare.outputs.ahead_by }}"
          echo "behind_by:     ${{ steps.compare.outputs.behind_by }}"

      - name: üö¶ Decide if back-merge is needed
        id: gate
        env:
          STATUS: ${{ steps.compare.outputs.status }}
          AHEAD:  ${{ steps.compare.outputs.ahead_by }}
          BEHIND: ${{ steps.compare.outputs.behind_by }}
        run: |
          set -euo pipefail
          echo "Compare summary: status=${STATUS} ahead_by=${AHEAD} behind_by=${BEHIND}"
          # Open a back-merge whenever branches are NOT identical
          if [[ "${STATUS}" != "identical" ]]; then
            echo "should_backmerge=true" >> "$GITHUB_OUTPUT"
          else
            echo "should_backmerge=false" >> "$GITHUB_OUTPUT"
          fi

      - name: üîé Check for existing open PR main -> develop
        id: existing
        if: ${{ steps.gate.outputs.should_backmerge == 'true' }}
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const open = await github.paginate(github.rest.pulls.list, {
              owner, repo, state: 'open', base: 'develop', per_page: 100
            });
            const existing = open.find(p => p.head.ref === 'main' || (p.head.label && p.head.label.endsWith(':main')));
            core.setOutput('exists', String(Boolean(existing)));
            if (existing) {
              core.setOutput('number', existing.number.toString());
              core.info(`Existing PR #${existing.number} main -> develop`);
            } else {
              core.info('No existing PR main -> develop');
            }

      - name: üß™ Debug decision
        if: always()
        run: |
          echo "gate.should_backmerge=${{ steps.gate.outputs.should_backmerge }}"
          echo "existing.exists=${{ steps.existing.outputs.exists }}"
          echo "existing.number=${{ steps.existing.outputs.number }}"

      - name: üì¥ No back-merge needed
        if: ${{ steps.gate.outputs.should_backmerge != 'true' }}
        run: echo "Develop is not behind/diverged; skipping PR."

      - name: ‚ûï Open PR main -> develop
        id: create_pr
        if: ${{ steps.gate.outputs.should_backmerge == 'true' && steps.existing.outputs.exists == 'false' }}
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const title = 'Back-merge main -> develop (post-release)';
            const body = [
              'Automated back-merge after release/hotfix merge into **main**.',
              '',
              '- Source: `main`',
              '- Target: `develop`',
              '',
              'Resolve any conflicts in this PR if present.'
            ].join('\n');
            const pr = await github.rest.pulls.create({
              owner, repo, head: 'main', base: 'develop', title, body, draft: false,
              maintainer_can_modify: true
            });
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: pr.data.number, labels: ['back-merge'] });
            } catch (e) {
              core.info('Label add skipped (label may not exist).');
            }
            core.setOutput('number', pr.data.number.toString());
            core.setOutput('node_id', pr.data.node_id);
            core.info(`Opened PR #${pr.data.number} main -> develop`);

      - name: üî¢ Select PR number
        id: prnum
        if: ${{ steps.gate.outputs.should_backmerge == 'true' }}
        run: |
          set -euo pipefail
          if [[ "${{ steps.existing.outputs.exists }}" == "true" && -n "${{ steps.existing.outputs.number }}" ]]; then
            echo "number=${{ steps.existing.outputs.number }}" >> "$GITHUB_OUTPUT"
            echo "Using existing PR #${{ steps.existing.outputs.number }}"
          else
            echo "number=${{ steps.create_pr.outputs.number }}" >> "$GITHUB_OUTPUT"
            echo "Using newly created PR #${{ steps.create_pr.outputs.number }}"
          fi

      - name: ü§ñ Enable native Auto-merge (merge commit)
        id: enable_auto_merge
        if: ${{ steps.gate.outputs.should_backmerge == 'true' && steps.prnum.outputs.number }}
        uses: actions/github-script@v8
        continue-on-error: true
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = parseInt('${{ steps.prnum.outputs.number }}', 10);
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const prId = pr.node_id;

            try {
              // Hardcode mergeMethod to avoid forbidden variable name "method"
              await github.graphql(`
                mutation($prId: ID!) {
                  enablePullRequestAutoMerge(input: {
                    pullRequestId: $prId,
                    mergeMethod: MERGE
                  }) { clientMutationId }
                }
              `, { prId });
              core.info(`Auto-merge enabled on PR #${prNumber}.`);
              core.setOutput('auto_merge_enabled', 'true');
            } catch (e) {
              core.warning(`Could not enable native Auto-merge (is it enabled in repo settings?): ${e.message}`);
              core.setOutput('auto_merge_enabled', 'false');
            }

      - name: ‚è≥ "Fallback; wait until clean & merge (10 min max)"
        uses: actions/github-script@v8
        env:
          SHOULD_BACKMERGE: ${{ steps.gate.outputs.should_backmerge }}
          PRNUM: ${{ steps.prnum.outputs.number }}
          AUTO_ENABLED: ${{ steps.enable_auto_merge.outputs.auto_merge_enabled }}
        with:
          script: |
            const shouldBackmerge = process.env.SHOULD_BACKMERGE === 'true';
            const prnumStr = process.env.PRNUM || '';
            const autoEnabled = process.env.AUTO_ENABLED === 'true';

            if (!shouldBackmerge || !prnumStr || autoEnabled) {
              core.info(`Fallback not required (shouldBackmerge=${shouldBackmerge}, prnum=${!!prnumStr}, autoEnabled=${autoEnabled}). Skipping.`);
              return;
            }

            const { owner, repo } = context.repo;
            const prNumber = parseInt(prnumStr, 10);
            const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

            function summarizeRuns(checks) {
              const buckets = { queued:0, in_progress:0, success:0, neutral:0, skipped:0, failure:0, cancelled:0, timed_out:0, action_required:0, unknown:0 };
              for (const cr of checks.data.check_runs) {
                const c = cr.conclusion || '';
                if (c in buckets) buckets[c]++; else if (!cr.conclusion) buckets.in_progress++; else buckets.unknown++;
              }
              return Object.entries(buckets).filter(([,v])=>v>0).map(([k,v])=>`${k}:${v}`).join(', ');
            }

            for (let i = 1; i <= 30; i++) {
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              core.info(`Attempt ${i}: mergeable=${pr.mergeable} state=${pr.mergeable_state} draft=${pr.draft}`);

              if (pr.draft) { core.setFailed('PR is draft; not merging.'); return; }
              if (pr.mergeable_state === 'blocked') {
                core.info('PR is blocked (required reviews/contexts). Waiting‚Ä¶');
              }

              const sha = pr.head.sha;

              // Check runs + legacy statuses (for visibility only)
              const checks = await github.rest.checks.listForRef({ owner, repo, ref: sha, per_page: 100 });
              const runsSummary = summarizeRuns(checks);
              const statuses = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: sha });
              core.info(`Check runs: ${runsSummary || 'none'} | combined statuses: ${statuses.data.state}`);

              // Try to merge when GitHub says it's mergeable and not explicitly blocked.
              const canAttempt = pr.mergeable === true && pr.mergeable_state !== 'blocked';
              if (canAttempt) {
                try {
                  await github.rest.pulls.merge({
                    owner, repo, pull_number: prNumber, merge_method: 'merge',
                    commit_title: pr.title,
                    commit_message: 'Auto-merged back-merge PR #' + prNumber + ' (main -> develop)'
                  });
                  core.info('Merged PR #' + prNumber + '.');
                  return;
                } catch (e) {
                  core.info(`Merge attempt failed (will retry): ${e.status || ''} ${e.message}`);
                }
              }

              await sleep(20000);
            }

            core.setFailed('Timed out waiting for PR to become mergeable or for protections to clear.');
