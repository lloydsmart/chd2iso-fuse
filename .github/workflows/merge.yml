name: On merge to main (release/hotfix)

on:
  push:
    branches: [ main ]

concurrency:
  group: on-merge-${{ github.ref }}
  cancel-in-progress: false

jobs:
  detect:
    name: Detect merged PR
    if: "!contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]')"
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
      contents: read
    outputs:
      is_release: ${{ steps.out.outputs.is_release }}
      head_ref:   ${{ steps.out.outputs.head_ref }}
      pr_number:  ${{ steps.out.outputs.pr_number }}
    steps:
      - id: out
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const commitSha = context.payload?.head_commit?.id || context.sha;

            // Robust: find PRs associated with this commit (works for merge/squash/rebase)
            const prs = await github.paginate(
              github.rest.repos.listPullRequestsAssociatedWithCommit,
              { owner, repo, commit_sha: commitSha, per_page: 100 }
            );

            // Prefer a merged PR into main, and classify release/hotfix by head ref
            const pr = prs.find(p => p.merged_at && p.base?.ref === 'main');
            const headRef = pr?.head?.ref || '';
            const isRelease = Boolean(pr && (headRef.startsWith('release/') || headRef.startsWith('hotfix/')));

            core.setOutput('is_release', String(isRelease));
            core.setOutput('head_ref', headRef);
            core.setOutput('pr_number', pr?.number ?? '');
            core.info(pr
              ? `Found merged PR #${pr.number} from '${headRef}'`
              : 'No merged PR into main found for this commit');

  verify:
    name: Verify versions (Cargo / Debian / binary)
    needs: detect
    if: needs.detect.outputs.is_release == 'true'
    permissions:
      contents: read
    uses: ./.github/workflows/_verify-release.yml
    secrets: inherit

  tag:
    name: Create signed annotated tag vX.Y.Z
    needs: [detect, verify]
    if: needs.detect.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Preflight check (vars + secrets present)
        env:
          HAS_GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY != '' }}
          HAS_GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE != '' }}
          HAS_AUTHOR_NAME: ${{ vars.GIT_AUTHOR_NAME != '' }}
          HAS_AUTHOR_EMAIL: ${{ vars.GIT_AUTHOR_EMAIL != '' }}
          HAS_RELEASE_PAT: ${{ secrets.RELEASE_PAT != '' }}
        run: |
          set -euo pipefail
          missing=0
          if [ "${HAS_GPG_PRIVATE_KEY}" != "true" ]; then echo "::error::Secret GPG_PRIVATE_KEY is missing!"; missing=1; fi
          if [ "${HAS_GPG_PASSPHRASE}" != "true" ]; then echo "::error::Secret GPG_PASSPHRASE is missing!"; missing=1; fi
          if [ "${HAS_RELEASE_PAT}" != "true" ]; then echo "::error::Secret RELEASE_PAT is missing (required to push tag and trigger release)!"; missing=1; fi
          if [ "${HAS_AUTHOR_NAME}" != "true" ]; then echo "::warning::Variable GIT_AUTHOR_NAME is not set (will use default)."; fi
          if [ "${HAS_AUTHOR_EMAIL}" != "true" ]; then echo "::warning::Variable GIT_AUTHOR_EMAIL is not set (will use default)."; fi
          if [ $missing -eq 1 ]; then echo "Required secrets missing; cannot proceed."; exit 1; fi

      - name: Checkout main
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Ensure safe git dir
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Configure git identity (from Actions Variables)
        run: |
          set -euo pipefail
          NAME="${{ vars.GIT_AUTHOR_NAME }}"
          EMAIL="${{ vars.GIT_AUTHOR_EMAIL }}"
          : "${NAME:=Release Bot}"
          : "${EMAIL:=release-bot@users.noreply.github.com}"
          git config user.name  "${NAME}"
          git config user.email "${EMAIL}"
          git config commit.gpgsign true
          git config tag.gpgSign true
          echo "Using git identity: ${NAME} <${EMAIL}>"

      - name: Import GPG private key
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          gpgconf --kill gpg-agent
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          FPR="$(gpg --batch --list-secret-keys --with-colons | awk -F: '/^fpr:/ {print $10; exit}')"
          if [ -z "$FPR" ]; then echo "No secret key fingerprint found after import"; exit 1; fi
          echo "FPR=$FPR" >> "$GITHUB_ENV"
          git config user.signingkey "$FPR"

      - name: Install GPG wrapper for non-interactive signing
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          cat > "$GITHUB_WORKSPACE/gpg-wrapper.sh" <<'EOF'
          #!/usr/bin/env bash
          exec gpg --batch --pinentry-mode loopback --passphrase "${GPG_PASSPHRASE}" "$@"
          EOF
          chmod +x "$GITHUB_WORKSPACE/gpg-wrapper.sh"
          git config gpg.program "$GITHUB_WORKSPACE/gpg-wrapper.sh"

      - name: GPG sanity check (non-interactive)
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: echo "ok" | gpg --batch --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --clearsign >/dev/null

      - name: Read version from Cargo.toml
        id: ver
        run: |
          set -euo pipefail
          ver="$(sed -n 's/^version[[:space:]]*=[[:space:]]*"\(.*\)".*/\1/p' Cargo.toml | head -n1)"
          [[ -n "$ver" ]] || { echo "No version in Cargo.toml"; exit 1; }
          [[ "$ver" != *-dev* ]] || { echo "Version has -dev suffix; refusing to tag"; exit 1; }
          echo "val=$ver" >> "$GITHUB_OUTPUT"
          echo "Version: $ver"

      - name: Create & push signed tag (with PAT so Release workflow triggers)
        env:
          VER: ${{ steps.ver.outputs.val }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          RELEASE_PAT: ${{ secrets.RELEASE_PAT }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          tag="v${VER}"

          # Skip if tag already on remote
          if git ls-remote --tags origin "refs/tags/${tag}" | grep -q .; then
            echo "Tag ${tag} already exists on origin; nothing to do."
            exit 0
          fi

          export GPG_TTY=$(tty || true)
          git tag -s "${tag}" -m "chd2iso-fuse ${tag}"
          git tag -v "${tag}"

          # Use PAT so the tag push triggers `on: push` workflows
          git remote set-url origin "https://x-access-token:${RELEASE_PAT}@github.com/${REPO}.git"
          git push origin "refs/tags/${tag}"
          echo "Pushed signed tag ${tag} with PAT (should trigger Release workflow)"

  backmerge:
    name: Open back-merge PR (main -> develop)
    needs: [detect]  # decoupled from tag so it still runs if tagging is skipped/failed
    if: needs.detect.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Compare branches (is develop behind main?)
        id: compare
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const res = await github.rest.repos.compareCommits({
              owner, repo, base: 'develop', head: 'main'
            });
            core.setOutput('status', res.data.status);
            core.setOutput('ahead_by', String(res.data.ahead_by));
            core.setOutput('behind_by', String(res.data.behind_by));

      - name: Log compare result
        run: |
          echo "Compare status: ${{ steps.compare.outputs.status }}"
          echo "ahead_by:      ${{ steps.compare.outputs.ahead_by }}"
          echo "behind_by:     ${{ steps.compare.outputs.behind_by }}"

      - name: Decide if back-merge is needed
        id: gate
        env:
          STATUS: ${{ steps.compare.outputs.status }}
        run: |
          set -euo pipefail
          if [[ "$STATUS" == "behind" || "$STATUS" == "diverged" ]]; then
            echo "should_backmerge=true" >> "$GITHUB_OUTPUT"
          else
            echo "should_backmerge=false" >> "$GITHUB_OUTPUT"
          fi
          echo "Status: $STATUS"

      - name: Check for existing open PR main -> develop
        id: existing
        if: ${{ steps.gate.outputs.should_backmerge == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const open = await github.paginate(github.rest.pulls.list, {
              owner, repo, state: 'open', base: 'develop', per_page: 100
            });
            const exists = open.some(p => p.head.ref === 'main' || (p.head.label && p.head.label.endsWith(':main')));
            core.setOutput('exists', String(exists));

      - name: No back-merge needed
        if: ${{ steps.gate.outputs.should_backmerge != 'true' }}
        run: echo "Develop is not behind; skipping PR."

      - name: Open PR main -> develop
        if: ${{ steps.gate.outputs.should_backmerge == 'true' && steps.existing.outputs.exists == 'false' }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const title = 'Back-merge main -> develop (post-release)';
            const body = [
              'Automated back-merge after release/hotfix merge into **main**.',
              '',
              '- Source: `main`',
              '- Target: `develop`',
              '',
              'Resolve any conflicts in this PR if present.'
            ].join('\n');
            const pr = await github.rest.pulls.create({
              owner, repo, head: 'main', base: 'develop', title, body, draft: false,
              maintainer_can_modify: true
            });
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: pr.data.number, labels: ['back-merge'] });
            } catch (e) {
              core.info('Label add skipped (label may not exist).');
            }
            core.info(`Opened PR #${pr.data.number} main -> develop`)
