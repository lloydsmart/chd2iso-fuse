name: On merge to main (release/hotfix)

on:
  push:
    branches: [ main ]

concurrency:
  # Ensure one run per ref; avoid racing tag/backmerge for the same merge
  group: on-merge-${{ github.ref }}
  cancel-in-progress: false

jobs:
  detect:
    name: Detect merged PR
    # Ignore housekeeping commits that used [skip ci]
    if: "!contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]')"
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
      contents: read
    outputs:
      is_release: ${{ steps.out.outputs.is_release }}
      head_ref:   ${{ steps.out.outputs.head_ref }}
      pr_number:  ${{ steps.out.outputs.pr_number }}
    steps:
      - id: out
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const headSha = context.payload?.head_commit?.id || context.sha;
            // Find the PR whose merge_commit_sha == this push's head commit
            const prs = await github.paginate(github.rest.pulls.list, {
              owner, repo, state: 'closed', per_page: 100
            });
            const pr = prs.find(p => p.merged_at && p.merge_commit_sha === headSha);
            const headRef = pr?.head?.ref || '';
            const isRelease = Boolean(pr && (headRef.startsWith('release/') || headRef.startsWith('hotfix/')));
            core.setOutput('is_release', String(isRelease));
            core.setOutput('head_ref', headRef);
            core.setOutput('pr_number', pr?.number ?? '');
            core.info(pr
              ? `Found merged PR #${pr.number} from '${headRef}'`
              : 'No merged PR found for this commit');

  verify:
    name: Verify versions (Cargo / Debian / binary)
    needs: detect
    if: needs.detect.outputs.is_release == 'true'
    permissions:
      contents: read
    uses: ./.github/workflows/_verify-release.yml
    secrets: inherit

  tag:
    name: Create signed annotated tag vX.Y.Z
    needs: [detect, verify]
    if: needs.detect.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Preflight check (vars + secrets present)
        env:
          HAS_GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY != '' }}
          HAS_GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE != '' }}
          HAS_AUTHOR_NAME: ${{ vars.GIT_AUTHOR_NAME != '' }}
          HAS_AUTHOR_EMAIL: ${{ vars.GIT_AUTHOR_EMAIL != '' }}
        run: |
          set -euo pipefail
          missing=0
          if [ "${HAS_GPG_PRIVATE_KEY}" != "true" ]; then
            echo "::error::Secret GPG_PRIVATE_KEY is missing!"; missing=1
          fi
          if [ "${HAS_GPG_PASSPHRASE}" != "true" ]; then
            echo "::error::Secret GPG_PASSPHRASE is missing!"; missing=1
          fi
          if [ "${HAS_AUTHOR_NAME}" != "true" ]; then
            echo "::warning::Variable GIT_AUTHOR_NAME is not set (will use default)."
          fi
          if [ "${HAS_AUTHOR_EMAIL}" != "true" ]; then
            echo "::warning::Variable GIT_AUTHOR_EMAIL is not set (will use default)."
          fi
          if [ $missing -eq 1 ]; then
            echo "Required secrets missing; cannot proceed."
            exit 1
          fi

      - name: Checkout main
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Ensure safe git dir (for newer Git)
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Configure git identity for tagging (from Actions Variables)
        shell: bash
        run: |
          set -euo pipefail
          NAME="${{ vars.GIT_AUTHOR_NAME }}"
          EMAIL="${{ vars.GIT_AUTHOR_EMAIL }}"
          : "${NAME:=Release Bot}"
          : "${EMAIL:=release-bot@users.noreply.github.com}"
          git config user.name  "${NAME}"
          git config user.email "${EMAIL}"
          git config commit.gpgsign true
          git config tag.gpgSign true
          echo "Using git identity: ${NAME} <${EMAIL}>"

      - name: Import GPG private key
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg
          # Allow loopback pinentry for CI
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          gpgconf --kill gpg-agent
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          FPR="$(gpg --batch --list-secret-keys --with-colons | awk -F: '/^fpr:/ {print $10; exit}')"
          if [ -z "$FPR" ]; then
            echo "No secret key fingerprint found after import"; exit 1
          fi
          echo "FPR=$FPR" >> "$GITHUB_ENV"
          git config user.signingkey "$FPR"

      - name: Install GPG wrapper for non-interactive signing
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          cat > "$GITHUB_WORKSPACE/gpg-wrapper.sh" <<'EOF'
          #!/usr/bin/env bash
          # Pass CI flags to gpg so Git signing works non-interactively.
          exec gpg --batch --pinentry-mode loopback --passphrase "${GPG_PASSPHRASE}" "$@"
          EOF
          chmod +x "$GITHUB_WORKSPACE/gpg-wrapper.sh"
          git config gpg.program "$GITHUB_WORKSPACE/gpg-wrapper.sh"

      - name: GPG sanity check (non-interactive)
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: echo "ok" | gpg --batch --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --clearsign >/dev/null

      - name: Read version from Cargo.toml
        id: ver
        run: |
          set -euo pipefail
          ver="$(sed -n 's/^version[[:space:]]*=[[:space:]]*"\(.*\)".*/\1/p' Cargo.toml | head -n1)"
          [[ -n "$ver" ]] || { echo "No version in Cargo.toml"; exit 1; }
          [[ "$ver" != *-dev* ]] || { echo "Version has -dev suffix; refusing to tag"; exit 1; }
          echo "val=$ver" >> "$GITHUB_OUTPUT"
          echo "Version: $ver"

      - name: Create & push signed tag
        env:
          VER: ${{ steps.ver.outputs.val }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}   # ensure wrapper has the passphrase
        shell: bash
        run: |
          set -euo pipefail
          tag="v${VER}"

          # No-op if the tag already exists on origin
          if git ls-remote --tags origin "refs/tags/${tag}" | grep -q .; then
            echo "Tag ${tag} already exists on origin; nothing to do."
            exit 0
          fi

          # Make GPG happy in some environments
          export GPG_TTY=$(tty || true)

          # Create signed annotated tag (wrapper supplies GPG flags & passphrase)
          git tag -s "${tag}" -m "chd2iso-fuse ${tag}"

          # Verify signature (hard gate)
          git tag -v "${tag}"

          # Push tag
          git push origin "refs/tags/${tag}"
          echo "Pushed signed tag ${tag}"

backmerge:
  name: Open back-merge PR (main -> develop)
  needs: [detect]  # was [detect, tag]
  if: needs.detect.outputs.is_release == 'true'
  runs-on: ubuntu-latest
  permissions:
    contents: read
    pull-requests: write
    steps:
      - name: Compare branches (is develop behind main?)
        id: compare
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const res = await github.rest.repos.compareCommits({
              owner, repo, base: 'develop', head: 'main'
            });
            core.setOutput('status', res.data.status); // ahead | behind | diverged | identical
            core.setOutput('ahead_by', String(res.data.ahead_by));
            core.setOutput('behind_by', String(res.data.behind_by));

      - name: Decide if back-merge is needed
        id: gate
        env:
          STATUS: ${{ steps.compare.outputs.status }}
        run: |
          set -euo pipefail
          if [[ "$STATUS" == "behind" || "$STATUS" == "diverged" ]]; then
            echo "should_backmerge=true" >> "$GITHUB_OUTPUT"
          else
            echo "should_backmerge=false" >> "$GITHUB_OUTPUT"
          fi
          echo "Status: $STATUS"

      - name: Check for existing open PR main -> develop
        id: existing
        if: ${{ steps.gate.outputs.should_backmerge == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const open = await github.paginate(github.rest.pulls.list, {
              owner, repo, state: 'open', base: 'develop', per_page: 100
            });
            const exists = open.some(p => p.head.ref === 'main' || (p.head.label && p.head.label.endsWith(':main')));
            core.setOutput('exists', String(exists));

      - name: Open PR main -> develop
        if: ${{ steps.gate.outputs.should_backmerge == 'true' && steps.existing.outputs.exists == 'false' }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const title = 'Back-merge main -> develop (post-release)';
            const body = [
              'Automated back-merge after release/hotfix merge into **main**.',
              '',
              '- Source: `main`',
              '- Target: `develop`',
              '',
              'Resolve any conflicts in this PR if present.'
            ].join('\n');
            const pr = await github.rest.pulls.create({
              owner, repo,
              head: 'main',
              base: 'develop',
              title,
              body,
              draft: false,
              maintainer_can_modify: true
            });
            try {
              await github.rest.issues.addLabels({
                owner, repo, issue_number: pr.data.number,
                labels: ['back-merge']
              });
            } catch (e) {
              core.info('Label add skipped (label may not exist).');
            }
            core.info(`Opened PR #${pr.data.number} main -> develop`)
