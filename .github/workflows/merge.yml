name: On merge to main (release/hotfix)

on:
  push:
    branches: [ main ]

concurrency:
  group: on-merge-${{ github.ref }}
  cancel-in-progress: false

jobs:
  detect:
    name: Detect merged PR
    if: "!contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]')"
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
      contents: read
    outputs:
      is_release: ${{ steps.out.outputs.is_release }}
      head_ref:   ${{ steps.out.outputs.head_ref }}
      pr_number:  ${{ steps.out.outputs.pr_number }}
    steps:
      - id: out
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const commitSha = context.payload?.head_commit?.id || context.sha;
            // Robust: works for merge/squash/rebase
            const prs = await github.paginate(
              github.rest.repos.listPullRequestsAssociatedWithCommit,
              { owner, repo, commit_sha: commitSha, per_page: 100 }
            );
            const pr = prs.find(p => p.merged_at && p.base?.ref === 'main');
            const headRef = pr?.head?.ref || '';
            const isRelease = Boolean(pr && (headRef.startsWith('release/') || headRef.startsWith('hotfix/')));
            core.setOutput('is_release', String(isRelease));
            core.setOutput('head_ref', headRef);
            core.setOutput('pr_number', pr?.number ?? '');
            core.info(pr
              ? `Found merged PR #${pr.number} from '${headRef}'`
              : 'No merged PR into main found for this commit');

  verify:
    name: Verify versions (Cargo / Debian / binary)
    needs: detect
    if: needs.detect.outputs.is_release == 'true'
    permissions:
      contents: read
    uses: ./.github/workflows/_verify-release.yml
    secrets: inherit

  tag:
    name: Create signed annotated tag vX.Y.Z
    needs: [detect, verify]
    if: needs.detect.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Preflight check (vars + secrets present)
        env:
          HAS_GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY != '' }}
          HAS_GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE != '' }}
          HAS_AUTHOR_NAME: ${{ vars.GIT_AUTHOR_NAME != '' }}
          HAS_AUTHOR_EMAIL: ${{ vars.GIT_AUTHOR_EMAIL != '' }}
          HAS_RELEASE_PAT: ${{ secrets.RELEASE_PAT != '' }}
        run: |
          set -euo pipefail
          missing=0
          if [ "${HAS_GPG_PRIVATE_KEY}" != "true" ]; then echo "::error::Secret GPG_PRIVATE_KEY is missing!"; missing=1; fi
          if [ "${HAS_GPG_PASSPHRASE}" != "true" ]; then echo "::error::Secret GPG_PASSPHRASE is missing!"; missing=1; fi
          if [ "${HAS_RELEASE_PAT}" != "true" ]; then echo "::error::Secret RELEASE_PAT is missing (required to trigger release)!"; missing=1; fi
          if [ "${HAS_AUTHOR_NAME}" != "true" ]; then echo "::warning::Variable GIT_AUTHOR_NAME is not set (will use default)."; fi
          if [ "${HAS_AUTHOR_EMAIL}" != "true" ]; then echo "::warning::Variable GIT_AUTHOR_EMAIL is not set (will use default)."; fi
          if [ $missing -eq 1 ]; then echo "Required secrets missing; cannot proceed."; exit 1; fi

      - name: Checkout main
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Ensure safe git dir
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Configure git identity (from Actions Variables)
        run: |
          set -euo pipefail
          NAME="${{ vars.GIT_AUTHOR_NAME }}"
          EMAIL="${{ vars.GIT_AUTHOR_EMAIL }}"
          : "${NAME:=Release Bot}"
          : "${EMAIL:=release-bot@users.noreply.github.com}"
          git config user.name  "${NAME}"
          git config user.email "${EMAIL}"
          git config commit.gpgsign true
          git config tag.gpgSign true
          echo "Using git identity: ${NAME} <${EMAIL}>"

      - name: Import GPG private key
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          gpgconf --kill gpg-agent
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          FPR="$(gpg --batch --list-secret-keys --with-colons | awk -F: '/^fpr:/ {print $10; exit}')"
          if [ -z "$FPR" ]; then echo "No secret key fingerprint found after import"; exit 1; fi
          echo "FPR=$FPR" >> "$GITHUB_ENV"
          git config user.signingkey "$FPR"

      - name: Install GPG wrapper for non-interactive signing
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          cat > "$GITHUB_WORKSPACE/gpg-wrapper.sh" <<'EOF'
          #!/usr/bin/env bash
          exec gpg --batch --pinentry-mode loopback --passphrase "${GPG_PASSPHRASE}" "$@"
          EOF
          chmod +x "$GITHUB_WORKSPACE/gpg-wrapper.sh"
          git config gpg.program "$GITHUB_WORKSPACE/gpg-wrapper.sh"

      - name: GPG sanity check (non-interactive)
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: echo "ok" | gpg --batch --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --clearsign >/dev/null

      - name: Read version from Cargo.toml
        id: ver
        run: |
          set -euo pipefail
          ver="$(sed -n 's/^version[[:space:]]*=[[:space:]]*"\(.*\)".*/\1/p' Cargo.toml | head -n1)"
          [[ -n "$ver" ]] || { echo "No version in Cargo.toml"; exit 1; }
          [[ "$ver" != *-dev* ]] || { echo "Version has -dev suffix; refusing to tag"; exit 1; }
          echo "val=$ver" >> "$GITHUB_OUTPUT"
          echo "Version: $ver"

      - name: Create & push signed tag (with PAT so Release workflow triggers)
        env:
          VER: ${{ steps.ver.outputs.val }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          RELEASE_PAT: ${{ secrets.RELEASE_PAT }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          tag="v${VER}"

          # Skip if tag already on remote
          if git ls-remote --tags origin "refs/tags/${tag}" | grep -q .; then
            echo "Tag ${tag} already exists on origin; nothing to do."
            exit 0
          fi

          export GPG_TTY=$(tty || true)
          git tag -s "${tag}" -m "chd2iso-fuse ${tag}"
          git tag -v "${tag}"

          # Use PAT so the tag push triggers `on: push` workflows
          git remote set-url origin "https://x-access-token:${RELEASE_PAT}@github.com/${REPO}.git"
          git push origin "refs/tags/${tag}"
          echo "Pushed signed tag ${tag} with PAT (should trigger Release workflow)"

      - name: Dispatch Release workflow for this tag (fallback)
        env:
          RELEASE_PAT: ${{ secrets.RELEASE_PAT }}
          REPO: ${{ github.repository }}
          TAG: v${{ steps.ver.outputs.val }}
        run: |
          set -euo pipefail
          echo "Dispatching release.yml for TAG=${TAG}"
          resp=$(curl -sS -o /tmp/resp.txt -w "%{http_code}" -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${RELEASE_PAT}" \
            "https://api.github.com/repos/${REPO}/actions/workflows/release.yml/dispatches" \
            -d "{\"ref\":\"main\",\"inputs\":{\"tag\":\"${TAG}\"}}")
          if [ "$resp" != "204" ]; then
            echo "::warning::Release dispatch returned HTTP ${resp}"
            sed -n '1,200p' /tmp/resp.txt || true
          else
            echo "Dispatched release.yml for ${TAG}"
          fi

  backmerge:
    name: Open back-merge PR (main -> develop)
    needs: [detect]  # decoupled from tag so it still runs if tagging is skipped/failed
    if: needs.detect.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      checks: read
    steps:
      - name: Compare branches (is develop behind main?)
        id: compare
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const res = await github.rest.repos.compareCommits({
              owner, repo, base: 'develop', head: 'main'
            });
            core.setOutput('status', res.data.status);
            core.setOutput('ahead_by', String(res.data.ahead_by));
            core.setOutput('behind_by', String(res.data.behind_by));

      - name: Log compare result
        run: |
          echo "Compare status: ${{ steps.compare.outputs.status }}"
          echo "ahead_by:      ${{ steps.compare.outputs.ahead_by }}"
          echo "behind_by:     ${{ steps.compare.outputs.behind_by }}"

      - name: Decide if back-merge is needed
        id: gate
        env:
          STATUS: ${{ steps.compare.outputs.status }}
        run: |
          set -euo pipefail
          if [[ "$STATUS" == "behind" || "$STATUS" == "diverged" ]]; then
            echo "should_backmerge=true" >> "$GITHUB_OUTPUT"
          else
            echo "should_backmerge=false" >> "$GITHUB_OUTPUT"
          fi
          echo "Status: $STATUS"

      - name: Check for existing open PR main -> develop
        id: existing
        if: ${{ steps.gate.outputs.should_backmerge == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const open = await github.paginate(github.rest.pulls.list, {
              owner, repo, state: 'open', base: 'develop', per_page: 100
            });
            const existing = open.find(p => p.head.ref === 'main' || (p.head.label && p.head.label.endsWith(':main')));
            core.setOutput('exists', String(Boolean(existing)));
            if (existing) {
              core.setOutput('number', existing.number.toString());
              core.info(`Existing PR #${existing.number} main -> develop`);
            } else {
              core.info('No existing PR main -> develop');
            }

      - name: No back-merge needed
        if: ${{ steps.gate.outputs.should_backmerge != 'true' }}
        run: echo "Develop is not behind; skipping PR."

      - name: Open PR main -> develop
        id: create_pr
        if: ${{ steps.gate.outputs.should_backmerge == 'true' && steps.existing.outputs.exists == 'false' }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const title = 'Back-merge main -> develop (post-release)';
            const body = [
              'Automated back-merge after release/hotfix merge into **main**.',
              '',
              '- Source: `main`',
              '- Target: `develop`',
              '',
              'Resolve any conflicts in this PR if present.'
            ].join('\n');
            const pr = await github.rest.pulls.create({
              owner, repo, head: 'main', base: 'develop', title, body, draft: false,
              maintainer_can_modify: true
            });
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: pr.data.number, labels: ['back-merge'] });
            } catch (e) {
              core.info('Label add skipped (label may not exist).');
            }
            core.setOutput('number', pr.data.number.toString());
            core.setOutput('node_id', pr.data.node_id);
            core.info(`Opened PR #${pr.data.number} main -> develop`);

      - name: Select PR number
        id: prnum
        if: ${{ steps.gate.outputs.should_backmerge == 'true' }}
        run: |
          set -euo pipefail
          if [[ "${{ steps.existing.outputs.exists }}" == "true" && -n "${{ steps.existing.outputs.number }}" ]]; then
            echo "number=${{ steps.existing.outputs.number }}" >> "$GITHUB_OUTPUT"
            echo "Using existing PR #${{ steps.existing.outputs.number }}"
          else
            echo "number=${{ steps.create_pr.outputs.number }}" >> "$GITHUB_OUTPUT"
            echo "Using newly created PR #${{ steps.create_pr.outputs.number }}"
          fi

      - name: Enable native Auto-merge (merge commit)
        id: enable_auto_merge
        if: ${{ steps.gate.outputs.should_backmerge == 'true' && steps.prnum.outputs.number }}
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = parseInt('${{ steps.prnum.outputs.number }}', 10);
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const prId = pr.node_id;

            try {
              await github.graphql(`
                mutation($prId: ID!, $method: PullRequestMergeMethod!) {
                  enablePullRequestAutoMerge(input: {
                    pullRequestId: $prId,
                    mergeMethod: MERGE
                  }) { clientMutationId }
                }
              `, { prId, method: "MERGE" });
              core.info(`Auto-merge enabled on PR #${prNumber}.`);
              core.setOutput('auto_merge_enabled', 'true');
            } catch (e) {
              core.warning(`Could not enable native Auto-merge (is it enabled in repo settings?): ${e.message}`);
              core.setOutput('auto_merge_enabled', 'false');
            }

      - name: Fallback: wait until clean & merge (10 min max)
        uses: actions/github-script@v7
        env:
          SHOULD_BACKMERGE: ${{ steps.gate.outputs.should_backmerge }}
          PRNUM: ${{ steps.prnum.outputs.number }}
          AUTO_ENABLED: ${{ steps.enable_auto_merge.outputs.auto_merge_enabled }}
        with:
          script: |
            // Gate logic inline
            const shouldBackmerge = process.env.SHOULD_BACKMERGE === 'true';
            const prnum = process.env.PRNUM || '';
            const autoEnabled = process.env.AUTO_ENABLED === 'true';
            if (!shouldBackmerge || !prnum || autoEnabled) {
              core.info(`Fallback not required (shouldBackmerge=${shouldBackmerge}, prnum=${!!prnum}, autoEnabled=${autoEnabled}). Skipping.`);
              return;
            }

            const { owner, repo } = context.repo;
            const prNumber = parseInt(prnum, 10);
            const sleep = ms => new Promise(r => setTimeout(r, ms));

            for (let i = 1; i <= 30; i++) {
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              core.info(`Attempt ${i}: mergeable=${pr.mergeable} state=${pr.mergeable_state} draft=${pr.draft}`);

              if (pr.draft) { core.setFailed('PR is draft; not merging.'); return; }
              if (pr.mergeable === false || pr.mergeable_state === 'dirty') {
                core.setFailed('PR has conflicts; not merging.'); return;
              }

              const sha = pr.head.sha;

              const checks = await github.rest.checks.listForRef({ owner, repo, ref: sha, per_page: 100 });
              const allCheckRunsOK = checks.data.check_runs.every(cr =>
                ['success','neutral','skipped'].includes(cr.conclusion || '')
              );

              const statuses = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: sha });
              const statusesOK = statuses.data.state === 'success' || statuses.data.state === 'none';

              if ((pr.mergeable === true || pr.mergeable_state === 'clean') && allCheckRunsOK && statusesOK) {
                await github.rest.pulls.merge({
                  owner, repo, pull_number: prNumber, merge_method: 'merge',
                  commit_title: pr.title,
                  commit_message: `Auto-merged clean back-merge PR #${prNumber} (main -> develop)`
                });
                core.info(`Merged PR #${prNumber}.`);
                return;
              }

              await sleep(20000);
            }

            core.setFailed('Timed out waiting for PR to become clean & mergeable.');
