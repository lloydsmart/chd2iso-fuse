name: Reusable — Tick a checkbox on the release PR ☑️

on:
  workflow_call:
    inputs:
      branch:
        description: "Release/Hotfix branch name (e.g., release/1.2.3). Optional; will fall back to context."
        type: string
        required: false
      box:
        description: "Which box to tick: ci | bump | codeql (optional; inferred from workflow/job if omitted)"
        type: string
        required: false

permissions:
  contents: read
  pull-requests: write

jobs:
  tick:
    runs-on: ubuntu-latest
    steps:
      - name: 📝 Update PR body checkbox
        id: update
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Inputs (may be empty)
            const inputBranch = (core.getInput('branch') || '').trim();
            const inputWhich  = (core.getInput('box') || '').trim();

            // Fallbacks if branch not provided by caller
            const envBranch = (process.env.GITHUB_HEAD_REF || process.env.GITHUB_REF_NAME || '').trim();
            const branch = inputBranch || envBranch;

            // Infer 'box' from workflow/job names if omitted
            const wf  = (process.env.GITHUB_WORKFLOW || '').toLowerCase();
            const job = (process.env.GITHUB_JOB || '').toLowerCase();

            let whichRaw = inputWhich;
            if (!whichRaw) {
              if (wf.includes('codeql') || job.includes('codeql') || wf.includes('security')) {
                whichRaw = 'codeql';
              } else if (wf.includes('release prep') || wf.includes('autobump') || job.includes('bump') || job.includes('changelog')) {
                whichRaw = 'bump';
              } else if (wf.includes('ci') || job.includes('build') || job.includes('test') || job.includes('ci')) {
                whichRaw = 'ci';
              }
            }

            const which0 = (whichRaw || '').trim().toLowerCase();

            // Accept synonyms
            const alias = {
              'ci': 'ci', 'build': 'ci', 'tests': 'ci',
              'bump': 'bump', 'version': 'bump', 'changelog': 'bump',
              'codeql': 'codeql', 'security': 'codeql', 'scan': 'codeql',
            };
            const which = alias[which0];

            if (!branch) {
              core.setFailed('Missing branch. Provide "with: branch: ..." or run on PR/push where GITHUB_HEAD_REF/GITHUB_REF_NAME are set.');
              return;
            }
            if (!which) {
              core.setFailed(`Unknown or missing 'box'. Pass: ci | bump | codeql. (workflow="${process.env.GITHUB_WORKFLOW}", job="${process.env.GITHUB_JOB}")`);
              return;
            }

            // Only act for release/* or hotfix/*
            if (!(branch.startsWith('release/') || branch.startsWith('hotfix/'))) {
              core.info(`Branch "${branch}" is not release/* or hotfix/* — skipping.`);
              return;
            }

            // Exact lines expected in the PR template
            const mapping = {
              ci:     /^- \[ \] CI build & tests passed$/m,
              bump:   /^- \[ \] Version bump & changelog completed$/m,
              codeql: /^- \[ \] CodeQL security scan completed$/m,
            };
            const doneMapping = {
              ci:     '- [x] CI build & tests passed',
              bump:   '- [x] Version bump & changelog completed',
              codeql: '- [x] CodeQL security scan completed',
            };

            const { owner, repo } = context.repo;

            // Find the open PR from this branch -> main
            const { data: prs } = await github.rest.pulls.list({
              owner, repo, state: 'open',
              head: `${owner}:${branch}`,
              base: 'main'
            });
            const pr = prs[0];
            if (!pr) {
              core.setFailed(`No open PR from ${branch} to main`);
              return;
            }

            let body = pr.body || '';

            // If already ticked, nothing to do
            if (body.includes(doneMapping[which])) {
              core.info(`Box "${which}" already ticked for PR #${pr.number}`);
            } else {
              // Replace the unchecked line with the checked one
              const replaced = body.replace(mapping[which], doneMapping[which]);
              body = replaced;

              // If the expected unchecked line is missing (manual edits), append a checked line as a safeguard
              if (!body.includes(doneMapping[which])) {
                body += `\n${doneMapping[which]}`;
              }

              await github.rest.pulls.update({ owner, repo, pull_number: pr.number, body });
              core.info(`Ticked "${which}" for PR #${pr.number}`);
            }

            // If ALL three are checked, flip draft -> Ready for review (GraphQL)
            const allChecked =
              body.includes(doneMapping.ci) &&
              body.includes(doneMapping.bump) &&
              body.includes(doneMapping.codeql);

            if (allChecked) {
              try {
                const mutation = `
                  mutation($prId: ID!) {
                    markPullRequestReadyForReview(input: { pullRequestId: $prId }) {
                      clientMutationId
                    }
                  }
                `;
                await github.graphql(mutation, { prId: pr.node_id });
                core.info(`All boxes checked. PR #${pr.number} marked Ready for review.`);
              } catch (e) {
                core.warning(`Tried to mark PR #${pr.number} ready: ${e.message}`);
              }
            } else {
              core.info(`All checked? ${allChecked}. Not flipping yet.`);
            }
