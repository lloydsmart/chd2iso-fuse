# .github/workflows/_build.yml
name: Reusable ‚Äì Build üì¶üõ†Ô∏è

on:
  workflow_call:
    inputs:
      lane:
        type: string
        required: true
      nightly:
        type: boolean
        default: false
      # force tag-like behavior for artifact naming and notes generation
      release_mode:
        type: boolean
        default: false
      # NEW: canonical tag to generate notes/CHANGELOG once
      tag:
        type: string
        required: false
    secrets: {}

# Ensure every run: step executes with Bash (fixes shopt/compgen)
defaults:
  run:
    shell: bash

jobs:
  rust-deb:
    name: Rust build & tests (chd2iso-fuse) ü¶Äüß™üì¶
    runs-on: ubuntu-latest
    container:
      image: debian:trixie
      options: --init
    env:
      RUSTC_WRAPPER: sccache
      SCCACHE_DIR: ${{ github.workspace }}/.sccache
      SCCACHE_CACHE_SIZE: 2G
      RUSTFLAGS: "--remap-path-prefix=${{ github.workspace }}=."
      DEBFULLNAME: "Lloyd Smart"
      DEBEMAIL: "lloydsmart@users.noreply.github.com"
      EMAIL: "lloydsmart@users.noreply.github.com"

    steps:
      - name: üß∞ Install git for checkout & basic tooling
        run: |
          set -euo pipefail
          apt-get update
          DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
            bash git ca-certificates

      - name: üì• Checkout (with tags; use provided tag if any)
        uses: actions/checkout@v5
        with:
          ref: ${{ inputs.tag || '' }}
          fetch-depth: 0
          fetch-tags: true

      - name: üë§ Configure git trust and identity
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git config --global user.name  "Lloyd Smart"
          git config --global user.email "lloydsmart@users.noreply.github.com"

      - name: üîê Hash Cargo.lock
        id: cargo_lock
        run: |
          if [ -f Cargo.lock ]; then
            echo "val=$(sha256sum Cargo.lock | cut -d' ' -f1)" >> "$GITHUB_OUTPUT"
          else
            echo "val=none" >> "$GITHUB_OUTPUT"
          fi

      - name: üóÇÔ∏è Determine if Rust/package files changed
        id: paths
        if: ${{ github.ref_type != 'tag' }}   # avoid noisy 'before' warning on tag events
        uses: dorny/paths-filter@v3
        with:
          filters: |
            rust:
              - 'src/**'
              - '**/*.rs'
              - 'Cargo.toml'
              - 'Cargo.lock'
              - 'build.rs'
              - 'debian/**'
              - 'Makefile'

      # PR only: allow noop when nothing relevant changed
      - name: üí§ No-op (non-code PR)
        if: ${{ github.event_name == 'pull_request' && !inputs.release_mode && github.ref_type != 'tag' && steps.paths.outputs.rust != 'true' }}
        run: echo "No Rust/package changes in this PR; skipping heavy build steps."

      - name: üõ†Ô∏è Install toolchain & deps
        if: ${{ steps.paths.outputs.rust == 'true' || github.event_name != 'pull_request' || inputs.release_mode || github.ref_type == 'tag' }}
        run: |
          set -euo pipefail
          apt-get update
          apt-get install -y --no-install-recommends \
            curl ca-certificates git build-essential pkg-config \
            libfuse3-dev fuse3 \
            gcc g++ make \
            rust-all \
            debhelper devscripts dh-cargo lintian \
            bats shellcheck \
            sccache || true

          if ! command -v sccache >/dev/null 2>&1; then
            cargo install sccache --locked
            ln -sf "$HOME/.cargo/bin/sccache" /usr/local/bin/sccache
          fi

          rustc -V; cargo -V; sccache --version || true

      - name: üìÇ Prepare sccache dir
        if: ${{ steps.paths.outputs.rust == 'true' || github.event_name != 'pull_request' || inputs.release_mode || github.ref_type == 'tag' }}
        run: |
          set -euo pipefail
          mkdir -p .sccache

      - name: üóÉÔ∏è Cache sccache
        if: ${{ steps.paths.outputs.rust == 'true' || github.event_name != 'pull_request' || inputs.release_mode || github.ref_type == 'tag' }}
        uses: actions/cache@v4
        with:
          path: .sccache
          key: sccache-${{ runner.os }}-${{ steps.cargo_lock.outputs.val }}-${{ github.ref_name }}
          restore-keys: |
            sccache-${{ runner.os }}-${{ steps.cargo_lock.outputs.val }}-
            sccache-${{ runner.os }}-

      - name: üéØ Rust fmt & clippy
        if: ${{ steps.paths.outputs.rust == 'true' || github.event_name != 'pull_request' || inputs.release_mode || github.ref_type == 'tag' }}
        run: |
          cargo fmt --all -- --check
          cargo clippy --workspace --all-targets -- -D warnings

      - name: üß™ Rust tests
        if: ${{ steps.paths.outputs.rust == 'true' || github.event_name != 'pull_request' || inputs.release_mode || github.ref_type == 'tag' }}
        run: cargo test --workspace --locked --all-features

      - name: üèóÔ∏è Debian build
        if: ${{ steps.paths.outputs.rust == 'true' || github.event_name != 'pull_request' || inputs.release_mode || github.ref_type == 'tag' }}
        env:
          DEB_BUILD_OPTIONS: nocheck
          RUSTC_WRAPPER: ${{ env.RUSTC_WRAPPER }}
          SCCACHE_DIR: ${{ env.SCCACHE_DIR }}
        run: |
          set -euo pipefail
          dpkg-buildpackage -us -uc -b
          mkdir -p artifacts
          mv ../*.deb ../*.buildinfo ../*.changes artifacts/ || true
          shopt -s nullglob
          if compgen -G "artifacts/*" > /dev/null; then
            (cd artifacts && sha256sum * > SHA256SUMS)
          fi
          
      - name: üîé Guard at least one .deb was built
        if: ${{ steps.paths.outputs.rust == 'true' || github.event_name != 'pull_request' || inputs.release_mode || github.ref_type == 'tag' }}
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          debs=(artifacts/*.deb)
          if [ ${#debs[@]} -eq 0 ]; then
            echo "::error::No .deb files found in artifacts/. Build or packaging likely failed."
            echo "Listing artifacts dir for debugging:"
            ls -la artifacts || true
            exit 1
          fi
          echo "Found ${#debs[@]} .deb file(s):"
          printf ' - %s\n' "${debs[@]}"

      # Canonical one-time generation of RELEASE_NOTES.md and CHANGELOG.md
      - name: üìù Generate release notes & CHANGELOG (git-cliff) ‚Äî canonical
        if: ${{ inputs.release_mode || github.ref_type == 'tag' }}
        env:
          TAG: ${{ inputs.tag }}
        run: |
          set -euo pipefail
          # Ensure curl available (installed above). Install git-cliff prebuilt binary.
          if ! command -v git-cliff >/dev/null 2>&1; then
            echo "Installing git-cliff‚Ä¶"
            curl -sSfL https://raw.githubusercontent.com/taiki-e/install-action/main/install.sh \
              | bash -s -- -b /usr/local/bin git-cliff
          fi

          [[ -n "${TAG}" ]] || { echo "::error::No TAG provided to _build.yml for release_mode build."; exit 1; }

          NOTES="RELEASE_NOTES.md"
          : > "$NOTES"

          # Previous tag using semver order, excluding current
          PREV="$(git tag --list 'v*' --sort=-v:refname | grep -Fvx "$TAG" | head -n1 || true)"

          if [[ -n "${PREV}" ]]; then
            COUNT="$(git rev-list --count "${PREV}..${TAG}" || echo 0)"
            echo "Prev tag: ${PREV} ‚Äî commits in range: ${COUNT}"
            if [[ "${COUNT}" -eq 0 ]]; then
              echo "::error::No commits between ${PREV} and ${TAG}."
              exit 1
            fi
            git-cliff --from "${PREV}" --to "${TAG}" --output "$NOTES"
          else
            echo "::warning::No previous tag found; generating for ${TAG} only."
            git-cliff --tag "${TAG}" --output "$NOTES"
          fi

          if [[ ! -s "$NOTES" ]] || grep -qiE '^\s*\(no notes\)\s*$' "$NOTES"; then
            echo "::error::Generated notes are empty or '(no notes)'."
            exit 1
          fi

          # Build/ensure CHANGELOG.md and prepend this section
          [[ -f CHANGELOG.md ]] || printf "# Changelog\n\n" > CHANGELOG.md
          new="$(mktemp)"
          awk -v sec="$NOTES" '
            NR==1 { print; print ""; system("cat " sec); next }
            { print }
          ' CHANGELOG.md > "$new"
          mv "$new" CHANGELOG.md

          # Stage canonical copies into artifacts/
          mkdir -p artifacts
          cp -v RELEASE_NOTES.md CHANGELOG.md artifacts/

      - name: üîç Lintian (non-fatal)
        if: ${{ steps.paths.outputs.rust == 'true' || github.event_name != 'pull_request' || inputs.release_mode || github.ref_type == 'tag' }}
        continue-on-error: true
        run: |
          if compgen -G "artifacts/*.deb" > /dev/null; then
            lintian artifacts/*.deb || true
          fi

      # Deterministic artifact name for releases
      - name: üè∑Ô∏è Set artifact name
        id: aname
        run: |
          set -euo pipefail
          if [ "${{ inputs.release_mode }}" = "true" ] || [ "${GITHUB_REF_TYPE}" = "tag" ]; then
            echo "val=release-artifacts" >> "$GITHUB_OUTPUT"
          elif [ "${{ inputs.nightly }}" = "true" ]; then
            echo "val=chd2iso-fuse-nightly-${GITHUB_RUN_ID}-${GITHUB_SHA}" >> "$GITHUB_OUTPUT"
          else
            echo "val=chd2iso-fuse-${{ inputs.lane }}-${GITHUB_SHA}" >> "$GITHUB_OUTPUT"
          fi

      - name: ‚¨ÜÔ∏è Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.aname.outputs.val }}
          path: artifacts/
          if-no-files-found: error

      - name: üßæ Debug list artifact contents
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          echo "Local artifacts/ contents prior to upload:"
          find artifacts -maxdepth 1 -type f -printf '%P\n' | sort || true
